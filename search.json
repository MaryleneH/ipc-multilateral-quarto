[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dashboard",
    "section": "",
    "text": "Welcome to your IPC Multilateral Price Index Learning Journey"
  },
  {
    "objectID": "index.html#your-progress",
    "href": "index.html#your-progress",
    "title": "Dashboard",
    "section": "Your Progress",
    "text": "Your Progress\n\n\n\n\n\n\n0/4\n\n\nWeeks Completed\n\n\n\n\n\n\n\n0%\n\n\nOverall Progress\n\n\n\n\n\n\n\n0/12\n\n\nExercises Done\n\n\n\n\n\n\n\n~16h\n\n\nEstimated Time"
  },
  {
    "objectID": "index.html#skills-youll-master",
    "href": "index.html#skills-youll-master",
    "title": "Dashboard",
    "section": "Skills You’ll Master",
    "text": "Skills You’ll Master\n\n Elementary Indices  Bilateral Indices  Multilateral Methods  GEKS Framework  Chain Linking  R Programming  Python Analysis  Data Visualization"
  },
  {
    "objectID": "index.html#weekly-progress",
    "href": "index.html#weekly-progress",
    "title": "Dashboard",
    "section": "Weekly Progress",
    "text": "Weekly Progress\n\n\nWeek 1: Elementary Indices 0%\n\n\n\n\n\n\n\n\n\nWeek 2: Fisher & Törnqvist 0%\n\n\n\n\n\n\n\n\n\nWeek 3: GEKS Methods 0%\n\n\n\n\n\n\n\n\n\nWeek 4: Chain Linking 0%"
  },
  {
    "objectID": "index.html#learning-path-timeline",
    "href": "index.html#learning-path-timeline",
    "title": "Dashboard",
    "section": "Learning Path Timeline",
    "text": "Learning Path Timeline\n\n\n\n\n Week 1: Elementary Indices\n\n\nMaster the foundational price indices: Jevons, Dutot, and Carli. Learn calculation methods in R and Python with practical examples.\n\n\nNot Started\n\n\n\n\n\n\n Week 2: Bilateral Indices\n\n\nExplore Fisher and Törnqvist price indices. Understand their properties and implementation with real-world datasets.\n\n\nNot Started\n\n\n\n\n\n\n Week 3: Multilateral Methods\n\n\nDeep dive into GEKS and GEKS-Törnqvist methods for multilateral price comparisons across time and space.\n\n\nNot Started\n\n\n\n\n\n\n Week 4: Advanced Techniques\n\n\nLearn CCDI (Coordinated Consumer Price Index) and CPD (Country-Product-Dummy) methods, plus rolling and linking strategies.\n\n\nNot Started"
  },
  {
    "objectID": "index.html#quick-stats",
    "href": "index.html#quick-stats",
    "title": "Dashboard",
    "section": "Quick Stats",
    "text": "Quick Stats\n\n\n\n\nMetric\nValue\n\n\n\n\n Total Lessons\n12\n\n\n Code Examples\n24\n\n\n Visualizations\n16\n\n\n Exercises\n12\n\n\n Avg Time/Week\n4 hours"
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Dashboard",
    "section": "Getting Started",
    "text": "Getting Started\n\n Ready to Begin?\nStart with Week 1 to learn the fundamental elementary price indices. Each week builds on the previous one, so we recommend following the order presented.\n Go to Week 1"
  },
  {
    "objectID": "index.html#resources",
    "href": "index.html#resources",
    "title": "Dashboard",
    "section": "Resources",
    "text": "Resources\n\n\n Downloads\n\nSample datasets (CSV format)\nR code templates\nPython notebooks\nExercise solutions\n\n\n\n Need Help?\n\nReview the code examples\nCheck the documentation\nPractice with exercises\nRefer to the references"
  },
  {
    "objectID": "week3.html",
    "href": "week3.html",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "",
    "text": "Master GEKS and GEKS-Törnqvist for multilateral price comparisons"
  },
  {
    "objectID": "week3.html#overview",
    "href": "week3.html#overview",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "Overview",
    "text": "Overview\n\nThis week explores multilateral index methods that ensure transitivity when comparing prices across multiple time periods or regions simultaneously.\nLearning Objectives: - Understand the concept of transitivity in price indices - Implement GEKS (Gini-Éltető-Köves-Szulc) method - Master GEKS-Törnqvist (GEKS-T) approach - Apply multilateral methods to real-world data - Understand the window length trade-off\nTime Required: ~4 hours"
  },
  {
    "objectID": "week3.html#introduction-to-multilateral-methods",
    "href": "week3.html#introduction-to-multilateral-methods",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "1. Introduction to Multilateral Methods",
    "text": "1. Introduction to Multilateral Methods\n\n\nThe Transitivity Problem\nBilateral indices can fail the transitivity test:\n\\[\nP(0,2) \\neq P(0,1) \\times P(1,2)\n\\]\nThis means chaining bilateral indices can lead to chain drift.\n\nKey Concept: Multilateral methods ensure transitivity by comparing all time periods (or regions) simultaneously, making the index from A to C equal to the product of indices from A to B and B to C.\n\n\n\nWhy Multilateral Methods?\n\nTransitivity: Ensure consistent comparisons\nCharacteristicity: Use all available data\nStability: Reduce revision issues\nInternational: Compare across countries and time"
  },
  {
    "objectID": "week3.html#geks-method",
    "href": "week3.html#geks-method",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "2. GEKS Method",
    "text": "2. GEKS Method\n\n\nMathematical Formula\nThe GEKS method combines multiple bilateral comparisons. For comparing periods 0 and t using data from periods 0 to T:\n\\[\nP_{GEKS}(0,t) = \\left[\\prod_{j=0}^{T} \\frac{P_B(0,j)}{P_B(t,j)}\\right]^{1/(T+1)}\n\\]\nWhere: - \\(P_B(s,t)\\) = bilateral index between periods s and t - T = number of periods in the comparison window - The product is taken over all bridge periods j\n\n\nProperties\n\nTransitive by construction\nUses all available information\nSymmetric treatment of all periods\nCan use any bilateral index as base (Fisher, Törnqvist, etc.)\n\n\n\nR Implementation\n\nlibrary(tidyverse)\n\n# Generate sample data for 6 time periods\nset.seed(123)\nn_periods &lt;- 6\nn_items &lt;- 5\n\n# Create price and quantity data\nprice_data &lt;- matrix(NA, n_items, n_periods)\nquantity_data &lt;- matrix(NA, n_items, n_periods)\n\n# Initial prices and quantities\nprice_data[, 1] &lt;- c(10, 20, 15, 25, 30)\nquantity_data[, 1] &lt;- c(100, 50, 80, 40, 30)\n\n# Simulate price and quantity changes\nfor (t in 2:n_periods) {\n  price_data[, t] &lt;- price_data[, t-1] * runif(n_items, 0.98, 1.12)\n  quantity_data[, t] &lt;- quantity_data[, t-1] * runif(n_items, 0.95, 1.05)\n}\n\n# Fisher index function (from Week 2)\nfisher_bilateral &lt;- function(p_s, p_t, q_s, q_t) {\n  laspeyres &lt;- sum(p_t * q_s) / sum(p_s * q_s)\n  paasche &lt;- sum(p_t * q_t) / sum(p_s * q_t)\n  return(sqrt(laspeyres * paasche))\n}\n\n# GEKS index function\ngeks_index &lt;- function(price_data, quantity_data, period_0, period_t) {\n  n_periods &lt;- ncol(price_data)\n  \n  # Calculate all bilateral indices\n  bilateral_matrix &lt;- matrix(1, n_periods, n_periods)\n  \n  for (s in 1:n_periods) {\n    for (t in 1:n_periods) {\n      if (s != t) {\n        bilateral_matrix[s, t] &lt;- fisher_bilateral(\n          price_data[, s], price_data[, t],\n          quantity_data[, s], quantity_data[, t]\n        )\n      }\n    }\n  }\n  \n  # Calculate GEKS index\n  product &lt;- 1\n  for (j in 1:n_periods) {\n    product &lt;- product * (bilateral_matrix[period_0, j] / \n                          bilateral_matrix[period_t, j])\n  }\n  \n  geks &lt;- product^(1/n_periods)\n  return(geks)\n}\n\n# Calculate GEKS indices for all periods relative to period 1\ngeks_indices &lt;- numeric(n_periods)\ngeks_indices[1] &lt;- 1  # Base period\n\nfor (t in 2:n_periods) {\n  geks_indices[t] &lt;- geks_index(price_data, quantity_data, 1, t)\n}\n\n# Also calculate chain Fisher for comparison\nchain_fisher &lt;- numeric(n_periods)\nchain_fisher[1] &lt;- 1\n\nfor (t in 2:n_periods) {\n  fisher &lt;- fisher_bilateral(\n    price_data[, t-1], price_data[, t],\n    quantity_data[, t-1], quantity_data[, t]\n  )\n  chain_fisher[t] &lt;- chain_fisher[t-1] * fisher\n}\n\n# Create comparison data frame\ncomparison &lt;- data.frame(\n  Period = 1:n_periods,\n  GEKS = geks_indices,\n  Chain_Fisher = chain_fisher\n)\n\nprint(comparison)\n\n  Period     GEKS Chain_Fisher\n1      1 1.000000     1.000000\n2      2 1.070637     1.070558\n3      3 1.132790     1.132415\n4      4 1.232644     1.232333\n5      5 1.327921     1.327732\n6      6 1.357781     1.358189\n\n# Visualization\ncomparison_long &lt;- comparison %&gt;%\n  pivot_longer(cols = c(GEKS, Chain_Fisher), \n               names_to = \"Method\", values_to = \"Index\")\n\nggplot(comparison_long, aes(x = Period, y = Index, \n                            color = Method, group = Method)) +\n  geom_line(linewidth = 1.2) +\n  geom_point(size = 3) +\n  scale_color_manual(values = c(\"GEKS\" = \"#2563eb\", \n                                 \"Chain_Fisher\" = \"#f59e0b\")) +\n  labs(\n    title = \"GEKS vs Chain Fisher Index\",\n    subtitle = \"GEKS ensures transitivity across all periods\",\n    y = \"Price Index (Period 1 = 1.00)\",\n    x = \"Time Period\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.position = \"bottom\",\n    legend.title = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nPython Implementation\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Generate sample data\nnp.random.seed(123)\nn_periods = 6\nn_items = 5\n\n# Create price and quantity matrices\nprice_data = np.zeros((n_items, n_periods))\nquantity_data = np.zeros((n_items, n_periods))\n\n# Initial values\nprice_data[:, 0] = [10, 20, 15, 25, 30]\nquantity_data[:, 0] = [100, 50, 80, 40, 30]\n\n# Simulate changes\nfor t in range(1, n_periods):\n    price_data[:, t] = price_data[:, t-1] * np.random.uniform(0.98, 1.12, n_items)\n    quantity_data[:, t] = quantity_data[:, t-1] * np.random.uniform(0.95, 1.05, n_items)\n\ndef fisher_bilateral(p_s, p_t, q_s, q_t):\n    \"\"\"Calculate bilateral Fisher index\"\"\"\n    laspeyres = np.sum(p_t * q_s) / np.sum(p_s * q_s)\n    paasche = np.sum(p_t * q_t) / np.sum(p_s * q_t)\n    return np.sqrt(laspeyres * paasche)\n\ndef geks_index(price_data, quantity_data, period_0, period_t):\n    \"\"\"Calculate GEKS index between two periods\"\"\"\n    n_periods = price_data.shape[1]\n    \n    # Calculate all bilateral indices\n    bilateral_matrix = np.ones((n_periods, n_periods))\n    \n    for s in range(n_periods):\n        for t in range(n_periods):\n            if s != t:\n                bilateral_matrix[s, t] = fisher_bilateral(\n                    price_data[:, s], price_data[:, t],\n                    quantity_data[:, s], quantity_data[:, t]\n                )\n    \n    # Calculate GEKS\n    product = 1.0\n    for j in range(n_periods):\n        product *= bilateral_matrix[period_0, j] / bilateral_matrix[period_t, j]\n    \n    geks = product ** (1/n_periods)\n    return geks\n\n# Calculate GEKS indices\ngeks_indices = np.zeros(n_periods)\ngeks_indices[0] = 1.0\n\nfor t in range(1, n_periods):\n    geks_indices[t] = geks_index(price_data, quantity_data, 0, t)\n\n# Calculate chain Fisher for comparison\nchain_fisher = np.zeros(n_periods)\nchain_fisher[0] = 1.0\n\nfor t in range(1, n_periods):\n    fisher = fisher_bilateral(\n        price_data[:, t-1], price_data[:, t],\n        quantity_data[:, t-1], quantity_data[:, t]\n    )\n    chain_fisher[t] = chain_fisher[t-1] * fisher\n\n# Create comparison\ncomparison = pd.DataFrame({\n    'Period': range(1, n_periods + 1),\n    'GEKS': geks_indices,\n    'Chain_Fisher': chain_fisher\n})\n\nprint(comparison)\n\n   Period      GEKS  Chain_Fisher\n0       1  1.000000      1.000000\n1       2  1.047087      1.047096\n2       3  1.083977      1.083974\n3       4  1.170010      1.170003\n4       5  1.208064      1.208100\n5       6  1.260622      1.260614\n\n# Visualization\nplt.figure(figsize=(10, 6))\nplt.plot(comparison['Period'], comparison['GEKS'], \n         'o-', color='#2563eb', linewidth=2, markersize=8, label='GEKS')\nplt.plot(comparison['Period'], comparison['Chain_Fisher'], \n         's-', color='#f59e0b', linewidth=2, markersize=8, label='Chain Fisher')\n\nplt.xlabel('Time Period')\nplt.ylabel('Price Index (Period 1 = 1.00)')\nplt.title('GEKS vs Chain Fisher Index', fontsize=14, fontweight='bold')\nplt.legend()\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "week3.html#geks-törnqvist-geks-t",
    "href": "week3.html#geks-törnqvist-geks-t",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "3. GEKS-Törnqvist (GEKS-T)",
    "text": "3. GEKS-Törnqvist (GEKS-T)\n\n\nWhy GEKS-Törnqvist?\nGEKS-T combines the best of both worlds: - Törnqvist bilateral index (superlative, widely used) - GEKS method (ensures transitivity)\nThis is the recommended method by many statistical agencies for CPI calculations.\n\n\nR Implementation\n\n# Törnqvist bilateral function\ntornqvist_bilateral &lt;- function(p_s, p_t, q_s, q_t) {\n  # Expenditure shares\n  exp_s &lt;- p_s * q_s\n  exp_t &lt;- p_t * q_t\n  shares_s &lt;- exp_s / sum(exp_s)\n  shares_t &lt;- exp_t / sum(exp_t)\n  \n  # Average shares\n  avg_shares &lt;- (shares_s + shares_t) / 2\n  \n  # Price relatives\n  price_relatives &lt;- p_t / p_s\n  \n  # Törnqvist\n  tornqvist &lt;- exp(sum(avg_shares * log(price_relatives)))\n  return(tornqvist)\n}\n\n# GEKS-Törnqvist function\ngeks_tornqvist &lt;- function(price_data, quantity_data, period_0, period_t) {\n  n_periods &lt;- ncol(price_data)\n  \n  # Calculate all bilateral Törnqvist indices\n  bilateral_matrix &lt;- matrix(1, n_periods, n_periods)\n  \n  for (s in 1:n_periods) {\n    for (t in 1:n_periods) {\n      if (s != t) {\n        bilateral_matrix[s, t] &lt;- tornqvist_bilateral(\n          price_data[, s], price_data[, t],\n          quantity_data[, s], quantity_data[, t]\n        )\n      }\n    }\n  }\n  \n  # Calculate GEKS\n  product &lt;- 1\n  for (j in 1:n_periods) {\n    product &lt;- product * (bilateral_matrix[period_0, j] / \n                          bilateral_matrix[period_t, j])\n  }\n  \n  geks_t &lt;- product^(1/n_periods)\n  return(geks_t)\n}\n\n# Calculate GEKS-T indices\ngeks_t_indices &lt;- numeric(n_periods)\ngeks_t_indices[1] &lt;- 1\n\nfor (t in 2:n_periods) {\n  geks_t_indices[t] &lt;- geks_tornqvist(price_data, quantity_data, 1, t)\n}\n\n# Compare all methods\ncomparison_all &lt;- data.frame(\n  Period = 1:n_periods,\n  GEKS_Fisher = geks_indices,\n  GEKS_Tornqvist = geks_t_indices,\n  Chain_Fisher = chain_fisher\n)\n\nprint(comparison_all)\n\n  Period GEKS_Fisher GEKS_Tornqvist Chain_Fisher\n1      1    1.000000       1.000000     1.000000\n2      2    1.070637       1.070627     1.070558\n3      3    1.132790       1.132796     1.132415\n4      4    1.232644       1.232640     1.232333\n5      5    1.327921       1.327889     1.327732\n6      6    1.357781       1.357759     1.358189\n\n# Visualization\ncomparison_all_long &lt;- comparison_all %&gt;%\n  pivot_longer(cols = -Period, names_to = \"Method\", values_to = \"Index\")\n\nggplot(comparison_all_long, aes(x = Period, y = Index, \n                                color = Method, group = Method)) +\n  geom_line(linewidth = 1.2) +\n  geom_point(size = 3) +\n  scale_color_manual(values = c(\n    \"GEKS_Fisher\" = \"#2563eb\",\n    \"GEKS_Tornqvist\" = \"#10b981\",\n    \"Chain_Fisher\" = \"#f59e0b\"\n  )) +\n  labs(\n    title = \"Comparison of Multilateral Methods\",\n    subtitle = \"GEKS-Fisher vs GEKS-Törnqvist vs Chain Fisher\",\n    y = \"Price Index (Period 1 = 1.00)\",\n    x = \"Time Period\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.position = \"bottom\",\n    legend.title = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nPython Implementation\n\ndef tornqvist_bilateral(p_s, p_t, q_s, q_t):\n    \"\"\"Calculate bilateral Törnqvist index\"\"\"\n    exp_s = p_s * q_s\n    exp_t = p_t * q_t\n    shares_s = exp_s / exp_s.sum()\n    shares_t = exp_t / exp_t.sum()\n    \n    avg_shares = (shares_s + shares_t) / 2\n    price_relatives = p_t / p_s\n    \n    tornqvist = np.exp(np.sum(avg_shares * np.log(price_relatives)))\n    return tornqvist\n\ndef geks_tornqvist_index(price_data, quantity_data, period_0, period_t):\n    \"\"\"Calculate GEKS-Törnqvist index\"\"\"\n    n_periods = price_data.shape[1]\n    \n    # Calculate all bilateral Törnqvist indices\n    bilateral_matrix = np.ones((n_periods, n_periods))\n    \n    for s in range(n_periods):\n        for t in range(n_periods):\n            if s != t:\n                bilateral_matrix[s, t] = tornqvist_bilateral(\n                    price_data[:, s], price_data[:, t],\n                    quantity_data[:, s], quantity_data[:, t]\n                )\n    \n    # Calculate GEKS\n    product = 1.0\n    for j in range(n_periods):\n        product *= bilateral_matrix[period_0, j] / bilateral_matrix[period_t, j]\n    \n    return product ** (1/n_periods)\n\n# Calculate GEKS-T indices\ngeks_t_indices = np.zeros(n_periods)\ngeks_t_indices[0] = 1.0\n\nfor t in range(1, n_periods):\n    geks_t_indices[t] = geks_tornqvist_index(price_data, quantity_data, 0, t)\n\n# Compare all methods\ncomparison_all = pd.DataFrame({\n    'Period': range(1, n_periods + 1),\n    'GEKS_Fisher': geks_indices,\n    'GEKS_Tornqvist': geks_t_indices,\n    'Chain_Fisher': chain_fisher\n})\n\nprint(\"\\nComparison of all methods:\")\n\n\nComparison of all methods:\n\nprint(comparison_all)\n\n   Period  GEKS_Fisher  GEKS_Tornqvist  Chain_Fisher\n0       1     1.000000        1.000000      1.000000\n1       2     1.047087        1.047091      1.047096\n2       3     1.083977        1.083980      1.083974\n3       4     1.170010        1.170014      1.170003\n4       5     1.208064        1.208065      1.208100\n5       6     1.260622        1.260632      1.260614\n\n# Visualization\nplt.figure(figsize=(12, 7))\nplt.plot(comparison_all['Period'], comparison_all['GEKS_Fisher'], \n         'o-', color='#2563eb', linewidth=2, markersize=8, \n         label='GEKS-Fisher')\nplt.plot(comparison_all['Period'], comparison_all['GEKS_Tornqvist'], \n         's-', color='#10b981', linewidth=2, markersize=8, \n         label='GEKS-Törnqvist')\nplt.plot(comparison_all['Period'], comparison_all['Chain_Fisher'], \n         '^-', color='#f59e0b', linewidth=2, markersize=8, \n         label='Chain Fisher')\n\nplt.xlabel('Time Period', fontsize=12)\nplt.ylabel('Price Index (Period 1 = 1.00)', fontsize=12)\nplt.title('Comparison of Multilateral Methods', \n          fontsize=14, fontweight='bold')\nplt.legend(fontsize=10)\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "week3.html#rolling-window-geks",
    "href": "week3.html#rolling-window-geks",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "4. Rolling Window GEKS",
    "text": "4. Rolling Window GEKS\n\n\nThe Window Length Problem\nGEKS requires choosing a window length (number of periods to include): - Longer windows: More data, better characteristicity, but more revisions - Shorter windows: Fewer revisions, but less data utilization\nCommon choices: 13 months, 25 months\n\nTrade-off: Statistical agencies must balance data utilization against revision frequency when choosing window length.\n\n\n\nR Implementation with Rolling Windows\n\n# Function for rolling window GEKS\nrolling_geks &lt;- function(price_data, quantity_data, window_length) {\n  n_periods &lt;- ncol(price_data)\n  indices &lt;- numeric(n_periods)\n  indices[1] &lt;- 1\n  \n  for (t in 2:n_periods) {\n    # Determine window\n    window_start &lt;- max(1, t - window_length + 1)\n    window_end &lt;- t\n    \n    # Extract window data\n    window_prices &lt;- price_data[, window_start:window_end]\n    window_quantities &lt;- quantity_data[, window_start:window_end]\n    \n    # Calculate GEKS within window\n    # Reference period is first period in window\n    window_index &lt;- geks_index(window_prices, window_quantities, 1, \n                                window_end - window_start + 1)\n    \n    # Link to previous period's level\n    if (t &gt; window_length) {\n      # Use movement to link\n      indices[t] &lt;- indices[t-1] * (window_index / \n                      geks_index(window_prices, window_quantities, 1, \n                                (window_end - 1) - window_start + 1))\n    } else {\n      # Build up index from base\n      indices[t] &lt;- window_index\n    }\n  }\n  \n  return(indices)\n}\n\n# Calculate with different window lengths\nwindow_13 &lt;- rolling_geks(price_data, quantity_data, 13)\nwindow_6 &lt;- rolling_geks(price_data, quantity_data, 6)\n\ncomparison_windows &lt;- data.frame(\n  Period = 1:n_periods,\n  Window_13 = window_13,\n  Window_6 = window_6,\n  Full_GEKS = geks_indices\n)\n\nprint(comparison_windows)\n\n  Period Window_13 Window_6 Full_GEKS\n1      1  1.000000 1.000000  1.000000\n2      2  1.070558 1.070558  1.070637\n3      3  1.132555 1.132555  1.132790\n4      4  1.232618 1.232618  1.232644\n5      5  1.328047 1.328047  1.327921\n6      6  1.357781 1.357781  1.357781"
  },
  {
    "objectID": "week3.html#guided-exercise",
    "href": "week3.html#guided-exercise",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "5. Guided Exercise",
    "text": "5. Guided Exercise\n\n Exercise 1: Implement GEKS\nUsing the following data for 4 time periods and 3 items:\nPeriod 1: p=(10,20,15), q=(100,50,80)\nPeriod 2: p=(11,21,16), q=(95,52,78)\nPeriod 3: p=(12,22,17), q=(90,54,76)\nPeriod 4: p=(13,23,18), q=(88,56,74)\nTasks: 1. Calculate bilateral Fisher indices for all period pairs 2. Implement GEKS for periods 2, 3, and 4 (using period 1 as base) 3. Compare with chain Fisher indices 4. Verify transitivity property\n\n\n Exercise 2: Window Length Analysis\nCreate a dataset with 24 monthly periods: 1. Calculate GEKS with window lengths of 6, 13, and 25 months 2. Compare the revision patterns 3. Analyze the trade-offs 4. Visualize the differences"
  },
  {
    "objectID": "week3.html#key-takeaways",
    "href": "week3.html#key-takeaways",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "6. Key Takeaways",
    "text": "6. Key Takeaways\n\n What You’ve Learned:\n\nGEKS: Ensures transitivity through geometric averaging of bilateral comparisons\nGEKS-Törnqvist: Combines Törnqvist bilateral index with GEKS framework\nTransitivity: Critical property for consistent multilateral comparisons\nWindow length: Important practical consideration for implementation\nApplications: CPI calculations, international comparisons, regional price indices"
  },
  {
    "objectID": "week3.html#next-steps",
    "href": "week3.html#next-steps",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "Next Steps",
    "text": "Next Steps\n\nReady for Week 4?\nComplete your learning journey with advanced linking and alternative multilateral methods.\nWeek 4 Topics: - CCDI (Coordinated Consumer Price Index) - CPD (Country-Product-Dummy) method - Rolling window strategies - Linking techniques\n Continue to Week 4"
  },
  {
    "objectID": "week3.html#references",
    "href": "week3.html#references",
    "title": "Week 3: GEKS & GEKS-T Methods",
    "section": "References",
    "text": "References\n\n\nIvancic, L., Diewert, W.E., & Fox, K.J. (2011). “Scanner Data, Time Aggregation and the Construction of Price Indexes”\nHill, R.J. (2004). “Constructing Price Indexes Across Space and Time”\nde Haan, J., & Krsinich, F. (2014). “Scanner Data and the Treatment of Quality Change in Nonrevisable Price Indexes”"
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "",
    "text": "Master Fisher and Törnqvist price indices with quantity weights"
  },
  {
    "objectID": "week2.html#overview",
    "href": "week2.html#overview",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "Overview",
    "text": "Overview\n\nThis week explores bilateral price indices that incorporate quantity or expenditure weights. These “superlative” indices provide more accurate measures of price change.\nLearning Objectives: - Understand the role of quantity weights in price indices - Implement Fisher and Törnqvist indices - Learn about axiomatic and economic approaches - Compare properties of superlative indices\nTime Required: ~4 hours"
  },
  {
    "objectID": "week2.html#introduction-to-weighted-indices",
    "href": "week2.html#introduction-to-weighted-indices",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "1. Introduction to Weighted Indices",
    "text": "1. Introduction to Weighted Indices\n\n\nWhy Use Weights?\nElementary indices treat all items equally, but in reality: - Different items have different economic importance - Consumers spend varying amounts on different products - Weighted indices better reflect actual consumption patterns\n\nKey Concept: Bilateral indices compare prices between two time periods using quantity or expenditure weights to reflect economic importance.\n\n\n\nLaspeyres and Paasche\nBefore superlative indices, we have the foundational weighted indices:\nLaspeyres Index (base period weights): \\[\nP_L = \\frac{\\sum p_t q_0}{\\sum p_0 q_0}\n\\]\nPaasche Index (current period weights): \\[\nP_P = \\frac{\\sum p_t q_t}{\\sum p_0 q_t}\n\\]"
  },
  {
    "objectID": "week2.html#fisher-index",
    "href": "week2.html#fisher-index",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "2. Fisher Index",
    "text": "2. Fisher Index\n\n\nMathematical Formula\nThe Fisher index is the geometric mean of Laspeyres and Paasche indices:\n\\[\nP_F = \\sqrt{P_L \\times P_P} = \\sqrt{\\frac{\\sum p_t q_0}{\\sum p_0 q_0} \\times \\frac{\\sum p_t q_t}{\\sum p_0 q_t}}\n\\]\nWhere: - \\(p_t\\), \\(p_0\\) = prices in current and base periods - \\(q_t\\), \\(q_0\\) = quantities in current and base periods\n\n\nProperties\n\nSatisfies time reversal test: \\(P_F(0,t) \\times P_F(t,0) = 1\\)\nSatisfies factor reversal test\nConsidered a “superlative” index\nSymmetric treatment of base and current periods\n\n\n\nR Implementation\n\n# Function to calculate Laspeyres Index\nlaspeyres_index &lt;- function(p_current, p_base, q_base) {\n  laspeyres &lt;- sum(p_current * q_base) / sum(p_base * q_base)\n  return(laspeyres)\n}\n\n# Function to calculate Paasche Index\npaasche_index &lt;- function(p_current, p_base, q_current) {\n  paasche &lt;- sum(p_current * q_current) / sum(p_base * q_current)\n  return(paasche)\n}\n\n# Function to calculate Fisher Index\nfisher_index &lt;- function(p_current, p_base, q_current, q_base) {\n  laspeyres &lt;- laspeyres_index(p_current, p_base, q_base)\n  paasche &lt;- paasche_index(p_current, p_base, q_current)\n  fisher &lt;- sqrt(laspeyres * paasche)\n  return(fisher)\n}\n\n# Example data - prices and quantities for 5 products\np_base &lt;- c(10, 20, 15, 25, 30)\np_current &lt;- c(12, 22, 16, 28, 33)\nq_base &lt;- c(100, 50, 80, 40, 30)\nq_current &lt;- c(95, 55, 75, 45, 32)\n\n# Calculate indices\nlaspeyres &lt;- laspeyres_index(p_current, p_base, q_base)\npaasche &lt;- paasche_index(p_current, p_base, q_current)\nfisher &lt;- fisher_index(p_current, p_base, q_current, q_base)\n\ncat(\"Laspeyres Index:\", round(laspeyres, 4), \"\\n\")\n\nLaspeyres Index: 1.1157 \n\ncat(\"Paasche Index:\", round(paasche, 4), \"\\n\")\n\nPaasche Index: 1.1152 \n\ncat(\"Fisher Index:\", round(fisher, 4), \"\\n\")\n\nFisher Index: 1.1154 \n\ncat(\"\\nFisher change:\", round((fisher - 1) * 100, 2), \"%\\n\")\n\n\nFisher change: 11.54 %\n\n# Visualization\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Calculate expenditure shares\nexp_base &lt;- p_base * q_base\nexp_current &lt;- p_current * q_current\nshares_base &lt;- exp_base / sum(exp_base)\nshares_current &lt;- exp_current / sum(exp_current)\n\ndata &lt;- data.frame(\n  Item = paste(\"Item\", 1:5),\n  Price_Change = ((p_current / p_base - 1) * 100),\n  Base_Share = shares_base * 100,\n  Current_Share = shares_current * 100\n)\n\nggplot(data, aes(x = Item)) +\n  geom_col(aes(y = Price_Change, fill = \"Price Change\"), \n           position = \"dodge\", alpha = 0.8) +\n  geom_point(aes(y = Base_Share * 5, color = \"Base Share\"), \n             size = 4) +\n  geom_point(aes(y = Current_Share * 5, color = \"Current Share\"), \n             size = 4) +\n  scale_y_continuous(\n    name = \"Price Change (%)\",\n    sec.axis = sec_axis(~./5, name = \"Expenditure Share (%)\")\n  ) +\n  scale_fill_manual(values = c(\"Price Change\" = \"#2563eb\")) +\n  scale_color_manual(values = c(\"Base Share\" = \"#f59e0b\", \n                                 \"Current Share\" = \"#10b981\")) +\n  labs(\n    title = \"Price Changes and Expenditure Shares\",\n    subtitle = \"Fisher Index accounts for changing weights\",\n    x = \"Item\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.title = element_blank(),\n    legend.position = \"bottom\"\n  )\n\n\n\n\n\n\n\n\n\n\nPython Implementation\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef laspeyres_index(p_current, p_base, q_base):\n    \"\"\"Calculate Laspeyres price index\"\"\"\n    return np.sum(p_current * q_base) / np.sum(p_base * q_base)\n\ndef paasche_index(p_current, p_base, q_current):\n    \"\"\"Calculate Paasche price index\"\"\"\n    return np.sum(p_current * q_current) / np.sum(p_base * q_current)\n\ndef fisher_index(p_current, p_base, q_current, q_base):\n    \"\"\"Calculate Fisher price index\"\"\"\n    laspeyres = laspeyres_index(p_current, p_base, q_base)\n    paasche = paasche_index(p_current, p_base, q_current)\n    return np.sqrt(laspeyres * paasche)\n\n# Example data\np_base = np.array([10, 20, 15, 25, 30])\np_current = np.array([12, 22, 16, 28, 33])\nq_base = np.array([100, 50, 80, 40, 30])\nq_current = np.array([95, 55, 75, 45, 32])\n\n# Calculate indices\nlaspeyres = laspeyres_index(p_current, p_base, q_base)\npaasche = paasche_index(p_current, p_base, q_current)\nfisher = fisher_index(p_current, p_base, q_current, q_base)\n\nprint(f\"Laspeyres Index: {laspeyres:.4f}\")\n\nLaspeyres Index: 1.1157\n\nprint(f\"Paasche Index: {paasche:.4f}\")\n\nPaasche Index: 1.1152\n\nprint(f\"Fisher Index: {fisher:.4f}\")\n\nFisher Index: 1.1154\n\nprint(f\"\\nFisher change: {(fisher - 1) * 100:.2f}%\")\n\n\nFisher change: 11.54%\n\n# Visualization\nexp_base = p_base * q_base\nexp_current = p_current * q_current\nshares_base = (exp_base / exp_base.sum()) * 100\nshares_current = (exp_current / exp_current.sum()) * 100\n\nfig, ax1 = plt.subplots(figsize=(12, 6))\n\nitems = [f'Item {i}' for i in range(1, 6)]\nx = np.arange(len(items))\nwidth = 0.6\n\nprice_change = ((p_current / p_base - 1) * 100)\n\nax1.bar(x, price_change, width, label='Price Change', \n        color='#2563eb', alpha=0.8)\nax1.set_xlabel('Item')\nax1.set_ylabel('Price Change (%)', color='#2563eb')\nax1.tick_params(axis='y', labelcolor='#2563eb')\nax1.set_xticks(x)\nax1.set_xticklabels(items)\n\nax2 = ax1.twinx()\nax2.plot(x, shares_base, 'o-', color='#f59e0b', \n         markersize=8, linewidth=2, label='Base Share')\nax2.plot(x, shares_current, 's-', color='#10b981', \n         markersize=8, linewidth=2, label='Current Share')\nax2.set_ylabel('Expenditure Share (%)')\n\nplt.title('Price Changes and Expenditure Shares', \n          fontsize=14, fontweight='bold')\n\n# Combine legends\nlines1, labels1 = ax1.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax1.legend(lines1 + lines2, labels1 + labels2, loc='upper left')\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "week2.html#törnqvist-index",
    "href": "week2.html#törnqvist-index",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "3. Törnqvist Index",
    "text": "3. Törnqvist Index\n\n\nMathematical Formula\nThe Törnqvist index uses logarithmic price relatives with average expenditure shares:\n\\[\n\\ln P_T = \\sum_{i=1}^{n} \\frac{1}{2}(s_i^0 + s_i^t) \\ln\\left(\\frac{p_i^t}{p_i^0}\\right)\n\\]\nWhere: - \\(s_i^0 = \\frac{p_i^0 q_i^0}{\\sum p_j^0 q_j^0}\\) = expenditure share in base period - \\(s_i^t = \\frac{p_i^t q_i^t}{\\sum p_j^t q_j^t}\\) = expenditure share in current period\nEquivalently: \\[\nP_T = \\prod_{i=1}^{n} \\left(\\frac{p_i^t}{p_i^0}\\right)^{\\frac{1}{2}(s_i^0 + s_i^t)}\n\\]\n\n\nProperties\n\nAlso a superlative index\nSatisfies time reversal test\nBased on Translog expenditure function\nCommonly used in practice (e.g., CPI calculations)\nTreats price relatives multiplicatively\n\n\n\nR Implementation\n\n# Function to calculate Törnqvist Index\ntornqvist_index &lt;- function(p_current, p_base, q_current, q_base) {\n  # Calculate expenditure shares\n  exp_base &lt;- p_base * q_base\n  exp_current &lt;- p_current * q_current\n  \n  shares_base &lt;- exp_base / sum(exp_base)\n  shares_current &lt;- exp_current / sum(exp_current)\n  \n  # Average shares\n  avg_shares &lt;- (shares_base + shares_current) / 2\n  \n  # Price relatives\n  price_relatives &lt;- p_current / p_base\n  \n  # Törnqvist index\n  tornqvist &lt;- exp(sum(avg_shares * log(price_relatives)))\n  \n  return(tornqvist)\n}\n\n# Calculate index\ntornqvist &lt;- tornqvist_index(p_current, p_base, q_current, q_base)\n\ncat(\"Törnqvist Index:\", round(tornqvist, 4), \"\\n\")\n\nTörnqvist Index: 1.1154 \n\ncat(\"Törnqvist change:\", round((tornqvist - 1) * 100, 2), \"%\\n\")\n\nTörnqvist change: 11.54 %\n\n# Compare all indices\nindices &lt;- data.frame(\n  Index = c(\"Laspeyres\", \"Paasche\", \"Fisher\", \"Törnqvist\"),\n  Value = c(laspeyres, paasche, fisher, tornqvist),\n  Change_Percent = c(\n    (laspeyres - 1) * 100,\n    (paasche - 1) * 100,\n    (fisher - 1) * 100,\n    (tornqvist - 1) * 100\n  )\n)\n\nprint(indices)\n\n      Index    Value Change_Percent\n1 Laspeyres 1.115686       11.56863\n2   Paasche 1.115209       11.52091\n3    Fisher 1.115448       11.54477\n4 Törnqvist 1.115418       11.54185\n\n# Visualization\nggplot(indices, aes(x = reorder(Index, Change_Percent), \n                    y = Change_Percent, fill = Index)) +\n  geom_col(alpha = 0.8, show.legend = FALSE) +\n  geom_text(aes(label = sprintf(\"%.2f%%\", Change_Percent)), \n            hjust = -0.2, fontface = \"bold\") +\n  coord_flip() +\n  scale_fill_manual(values = c(\n    \"Laspeyres\" = \"#ef4444\",\n    \"Paasche\" = \"#f59e0b\",\n    \"Fisher\" = \"#2563eb\",\n    \"Törnqvist\" = \"#10b981\"\n  )) +\n  labs(\n    title = \"Comparison of Price Indices\",\n    subtitle = \"Fisher and Törnqvist are superlative indices\",\n    x = \"Index Type\",\n    y = \"Price Change (%)\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nPython Implementation\n\ndef tornqvist_index(p_current, p_base, q_current, q_base):\n    \"\"\"Calculate Törnqvist price index\"\"\"\n    # Expenditure shares\n    exp_base = p_base * q_base\n    exp_current = p_current * q_current\n    \n    shares_base = exp_base / exp_base.sum()\n    shares_current = exp_current / exp_current.sum()\n    \n    # Average shares\n    avg_shares = (shares_base + shares_current) / 2\n    \n    # Price relatives\n    price_relatives = p_current / p_base\n    \n    # Törnqvist index\n    tornqvist = np.exp(np.sum(avg_shares * np.log(price_relatives)))\n    \n    return tornqvist\n\n# Calculate index\ntornqvist = tornqvist_index(p_current, p_base, q_current, q_base)\n\nprint(f\"Törnqvist Index: {tornqvist:.4f}\")\n\nTörnqvist Index: 1.1154\n\nprint(f\"Törnqvist change: {(tornqvist - 1) * 100:.2f}%\")\n\nTörnqvist change: 11.54%\n\n# Compare all indices\nindices_comparison = pd.DataFrame({\n    'Index': ['Laspeyres', 'Paasche', 'Fisher', 'Törnqvist'],\n    'Value': [laspeyres, paasche, fisher, tornqvist]\n})\nindices_comparison['Change_Percent'] = (indices_comparison['Value'] - 1) * 100\n\nprint(\"\\nComparison of Price Indices:\")\n\n\nComparison of Price Indices:\n\nprint(indices_comparison)\n\n       Index     Value  Change_Percent\n0  Laspeyres  1.115686       11.568627\n1    Paasche  1.115209       11.520913\n2     Fisher  1.115448       11.544767\n3  Törnqvist  1.115418       11.541847\n\n# Visualization\nplt.figure(figsize=(10, 6))\ncolors = ['#ef4444', '#f59e0b', '#2563eb', '#10b981']\nbars = plt.barh(indices_comparison['Index'], \n                indices_comparison['Change_Percent'], \n                color=colors, alpha=0.8)\n\nfor i, bar in enumerate(bars):\n    width = bar.get_width()\n    plt.text(width + 0.05, bar.get_y() + bar.get_height()/2, \n             f'{width:.2f}%', ha='left', va='center', fontweight='bold')\n\nplt.xlabel('Price Change (%)')\nplt.ylabel('Index Type')\nplt.title('Comparison of Price Indices', fontsize=14, fontweight='bold')\nplt.grid(axis='x', alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "week2.html#axiomatic-properties",
    "href": "week2.html#axiomatic-properties",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "4. Axiomatic Properties",
    "text": "4. Axiomatic Properties\n\n\nKey Tests for Price Indices\n\nTime Reversal Test: \\(P(0,t) \\times P(t,0) = 1\\)\nBoth Fisher and Törnqvist satisfy this test, meaning the index from period 0 to t multiplied by the index from t to 0 equals 1.\n\n\nFactor Reversal Test: Price index × Quantity index = Value ratio\nOnly the Fisher index satisfies this test perfectly.\n\n\n\nR Code to Test Properties\n\n# Time Reversal Test\ntest_time_reversal &lt;- function(index_func, p_current, p_base, \n                                q_current, q_base) {\n  forward &lt;- index_func(p_current, p_base, q_current, q_base)\n  backward &lt;- index_func(p_base, p_current, q_base, q_current)\n  product &lt;- forward * backward\n  \n  cat(\"Forward index:\", round(forward, 6), \"\\n\")\n  cat(\"Backward index:\", round(backward, 6), \"\\n\")\n  cat(\"Product:\", round(product, 6), \"\\n\")\n  cat(\"Passes test:\", abs(product - 1) &lt; 0.0001, \"\\n\\n\")\n}\n\ncat(\"Fisher Index - Time Reversal Test:\\n\")\n\nFisher Index - Time Reversal Test:\n\ntest_time_reversal(fisher_index, p_current, p_base, q_current, q_base)\n\nForward index: 1.115448 \nBackward index: 0.896501 \nProduct: 1 \nPasses test: TRUE \n\ncat(\"Törnqvist Index - Time Reversal Test:\\n\")\n\nTörnqvist Index - Time Reversal Test:\n\ntest_time_reversal(tornqvist_index, p_current, p_base, q_current, q_base)\n\nForward index: 1.115418 \nBackward index: 0.896525 \nProduct: 1 \nPasses test: TRUE \n\n\n\n\nPython Code to Test Properties\n\ndef test_time_reversal(index_func, p_current, p_base, q_current, q_base):\n    \"\"\"Test time reversal property\"\"\"\n    forward = index_func(p_current, p_base, q_current, q_base)\n    backward = index_func(p_base, p_current, q_base, q_current)\n    product = forward * backward\n    \n    print(f\"Forward index: {forward:.6f}\")\n    print(f\"Backward index: {backward:.6f}\")\n    print(f\"Product: {product:.6f}\")\n    print(f\"Passes test: {abs(product - 1) &lt; 0.0001}\\n\")\n\nprint(\"Fisher Index - Time Reversal Test:\")\n\nFisher Index - Time Reversal Test:\n\ntest_time_reversal(fisher_index, p_current, p_base, q_current, q_base)\n\nForward index: 1.115448\nBackward index: 0.896501\nProduct: 1.000000\nPasses test: True\n\nprint(\"Törnqvist Index - Time Reversal Test:\")\n\nTörnqvist Index - Time Reversal Test:\n\ntest_time_reversal(tornqvist_index, p_current, p_base, q_current, q_base)\n\nForward index: 1.115418\nBackward index: 0.896525\nProduct: 1.000000\nPasses test: True"
  },
  {
    "objectID": "week2.html#guided-exercise",
    "href": "week2.html#guided-exercise",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "5. Guided Exercise",
    "text": "5. Guided Exercise\n\n Exercise 1: Real-World Application\nYou have price and quantity data for a consumer basket:\nProduct A: p₀=50, q₀=20, p₁=55, q₁=18\nProduct B: p₀=100, q₀=10, p₁=105, q₁=11\nProduct C: p₀=25, q₀=40, p₁=30, q₁=35\nTasks: 1. Calculate Laspeyres, Paasche, Fisher, and Törnqvist indices 2. Explain why Laspeyres tends to be higher than Paasche 3. Calculate the expenditure shares in both periods 4. Create a visualization showing the relationships\n\n\n Exercise 2: Time Series Chain Indices\nCreate a time series with 12 months of data: 1. Calculate monthly Fisher indices 2. Create a chain-linked index series 3. Compare chain vs. fixed-base indices 4. Visualize the index evolution over time\nHint: Chain linking multiplies successive month-to-month indices"
  },
  {
    "objectID": "week2.html#key-takeaways",
    "href": "week2.html#key-takeaways",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "6. Key Takeaways",
    "text": "6. Key Takeaways\n\n What You’ve Learned:\n\nFisher Index: Geometric mean of Laspeyres and Paasche, excellent theoretical properties\nTörnqvist Index: Weighted geometric mean using average shares, widely used in practice\nBoth are “superlative” indices based on flexible functional forms\nWeighted indices provide more accurate measures than elementary indices\nTime reversal and factor reversal tests evaluate index quality"
  },
  {
    "objectID": "week2.html#next-steps",
    "href": "week2.html#next-steps",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "Next Steps",
    "text": "Next Steps\n\nReady for Week 3?\nNow that you understand bilateral indices, you’re ready to tackle multilateral comparisons.\nWeek 3 Topics: - GEKS method (Gini-Éltető-Köves-Szulc) - GEKS-Törnqvist - Multilateral comparisons - Transitivity properties\n Continue to Week 3"
  },
  {
    "objectID": "week2.html#references",
    "href": "week2.html#references",
    "title": "Week 2: Fisher & Törnqvist Indices",
    "section": "References",
    "text": "References\n\n\nDiewert, W.E. (1976). “Exact and Superlative Index Numbers”\nHill, R.J. (2004). “Constructing Price Indexes Across Space and Time”\nILO et al. (2020). Consumer Price Index Manual"
  },
  {
    "objectID": "week1.html",
    "href": "week1.html",
    "title": "Week 1: Elementary Indices",
    "section": "",
    "text": "Master the foundational price indices: Jevons, Dutot, and Carli"
  },
  {
    "objectID": "week1.html#overview",
    "href": "week1.html#overview",
    "title": "Week 1: Elementary Indices",
    "section": "Overview",
    "text": "Overview\n\nThis week focuses on the three fundamental elementary price indices used in price statistics. These indices form the building blocks for more complex price index calculations.\nLearning Objectives: - Understand the mathematical formulation of elementary indices - Implement Jevons, Dutot, and Carli indices in R and Python - Compare their properties and appropriate use cases - Apply indices to real-world price data\nTime Required: ~4 hours"
  },
  {
    "objectID": "week1.html#elementary-indices-introduction",
    "href": "week1.html#elementary-indices-introduction",
    "title": "Week 1: Elementary Indices",
    "section": "1. Elementary Indices Introduction",
    "text": "1. Elementary Indices Introduction\n\n\nWhat are Elementary Indices?\nElementary price indices are the simplest form of price indices, calculated without using quantity or expenditure weights. They’re typically used at the lowest level of aggregation in price statistics.\n\nKey Concept: Elementary indices compare prices between two time periods using only price relatives, without requiring quantity information.\n\n\n\nThe Three Main Types\n\nJevons Index - Geometric mean of price relatives\nDutot Index - Ratio of arithmetic means\nCarli Index - Arithmetic mean of price relatives"
  },
  {
    "objectID": "week1.html#jevons-index",
    "href": "week1.html#jevons-index",
    "title": "Week 1: Elementary Indices",
    "section": "2. Jevons Index",
    "text": "2. Jevons Index\n\n\nMathematical Formula\nThe Jevons index is defined as the geometric mean of price relatives:\n\\[\nI_{\\text{Jevons}} = \\left(\\prod_{i=1}^{n} \\frac{p_i^t}{p_i^0}\\right)^{1/n}\n\\]\nWhere: - \\(p_i^t\\) = price of item \\(i\\) in current period - \\(p_i^0\\) = price of item \\(i\\) in base period - \\(n\\) = number of items\n\n\nProperties\n\nSatisfies the time reversal test\nSymmetric treatment of periods\nPreferred for homogeneous products\nSensitive to extreme values in logarithmic form\n\n\n\nR Implementation\n\n# Function to calculate Jevons Index\njevons_index &lt;- function(prices_current, prices_base) {\n  # Calculate price relatives\n  price_relatives &lt;- prices_current / prices_base\n  \n  # Geometric mean\n  jevons &lt;- exp(mean(log(price_relatives)))\n  \n  return(jevons)\n}\n\n# Example data\nprices_base &lt;- c(10, 20, 15, 25, 30)\nprices_current &lt;- c(12, 22, 16, 28, 33)\n\n# Calculate index\nresult &lt;- jevons_index(prices_current, prices_base)\ncat(\"Jevons Index:\", round(result, 4), \"\\n\")\n\nJevons Index: 1.1165 \n\ncat(\"Percentage change:\", round((result - 1) * 100, 2), \"%\\n\")\n\nPercentage change: 11.65 %\n\n# Visualization\nlibrary(ggplot2)\nlibrary(dplyr)\n\ndata &lt;- data.frame(\n  Item = paste(\"Item\", 1:5),\n  Base = prices_base,\n  Current = prices_current,\n  Change = ((prices_current / prices_base - 1) * 100)\n)\n\nggplot(data, aes(x = Item, y = Change)) +\n  geom_col(fill = \"#2563eb\", alpha = 0.8) +\n  geom_hline(yintercept = (result - 1) * 100, \n             linetype = \"dashed\", color = \"#f59e0b\", size = 1) +\n  labs(\n    title = \"Price Changes by Item\",\n    subtitle = \"Dashed line shows Jevons Index average\",\n    y = \"Price Change (%)\",\n    x = \"Item\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nPython Implementation\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef jevons_index(prices_current, prices_base):\n    \"\"\"Calculate Jevons price index\"\"\"\n    price_relatives = prices_current / prices_base\n    jevons = np.exp(np.mean(np.log(price_relatives)))\n    return jevons\n\n# Example data\nprices_base = np.array([10, 20, 15, 25, 30])\nprices_current = np.array([12, 22, 16, 28, 33])\n\n# Calculate index\nresult = jevons_index(prices_current, prices_base)\nprint(f\"Jevons Index: {result:.4f}\")\n\nJevons Index: 1.1165\n\nprint(f\"Percentage change: {(result - 1) * 100:.2f}%\")\n\nPercentage change: 11.65%\n\n# Visualization\ndata = pd.DataFrame({\n    'Item': [f'Item {i}' for i in range(1, 6)],\n    'Base': prices_base,\n    'Current': prices_current\n})\ndata['Change'] = (data['Current'] / data['Base'] - 1) * 100\n\nplt.figure(figsize=(10, 6))\nplt.bar(data['Item'], data['Change'], color='#2563eb', alpha=0.8)\nplt.axhline(y=(result - 1) * 100, color='#f59e0b', \n            linestyle='--', linewidth=2, label='Jevons Index')\nplt.title('Price Changes by Item', fontsize=14, fontweight='bold')\nplt.ylabel('Price Change (%)')\nplt.xlabel('Item')\nplt.legend()\nplt.grid(axis='y', alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "week1.html#dutot-index",
    "href": "week1.html#dutot-index",
    "title": "Week 1: Elementary Indices",
    "section": "3. Dutot Index",
    "text": "3. Dutot Index\n\n\nMathematical Formula\nThe Dutot index is the ratio of arithmetic means of prices:\n\\[\nI_{\\text{Dutot}} = \\frac{\\frac{1}{n}\\sum_{i=1}^{n} p_i^t}{\\frac{1}{n}\\sum_{i=1}^{n} p_i^0} = \\frac{\\sum_{i=1}^{n} p_i^t}{\\sum_{i=1}^{n} p_i^0}\n\\]\n\n\nProperties\n\nSimple to calculate and interpret\nAssumes items are measured in comparable units\nSensitive to units of measurement\nBest for homogeneous items with similar price levels\n\n\n\nR Implementation\n\n# Function to calculate Dutot Index\ndutot_index &lt;- function(prices_current, prices_base) {\n  dutot &lt;- mean(prices_current) / mean(prices_base)\n  return(dutot)\n}\n\n# Calculate index\nresult &lt;- dutot_index(prices_current, prices_base)\ncat(\"Dutot Index:\", round(result, 4), \"\\n\")\n\nDutot Index: 1.11 \n\ncat(\"Percentage change:\", round((result - 1) * 100, 2), \"%\\n\")\n\nPercentage change: 11 %\n\n# Compare all three indices\nindices &lt;- data.frame(\n  Index = c(\"Jevons\", \"Dutot\", \"Carli\"),\n  Value = c(\n    jevons_index(prices_current, prices_base),\n    dutot_index(prices_current, prices_base),\n    NA  # Carli to be calculated next\n  )\n)\n\n# We'll complete this after defining Carli\n\n\n\nPython Implementation\n\ndef dutot_index(prices_current, prices_base):\n    \"\"\"Calculate Dutot price index\"\"\"\n    dutot = np.mean(prices_current) / np.mean(prices_base)\n    return dutot\n\n# Calculate index\nresult = dutot_index(prices_current, prices_base)\nprint(f\"Dutot Index: {result:.4f}\")\n\nDutot Index: 1.1100\n\nprint(f\"Percentage change: {(result - 1) * 100:.2f}%\")\n\nPercentage change: 11.00%"
  },
  {
    "objectID": "week1.html#carli-index",
    "href": "week1.html#carli-index",
    "title": "Week 1: Elementary Indices",
    "section": "4. Carli Index",
    "text": "4. Carli Index\n\n\nMathematical Formula\nThe Carli index is the arithmetic mean of price relatives:\n\\[\nI_{\\text{Carli}} = \\frac{1}{n}\\sum_{i=1}^{n} \\frac{p_i^t}{p_i^0}\n\\]\n\n\nProperties\n\nArithmetic mean of individual price changes\nHas an upward bias (fails time reversal test)\nGives equal weight to all price relatives\nLess commonly used due to bias issues\n\n\n\nR Implementation\n\n# Function to calculate Carli Index\ncarli_index &lt;- function(prices_current, prices_base) {\n  price_relatives &lt;- prices_current / prices_base\n  carli &lt;- mean(price_relatives)\n  return(carli)\n}\n\n# Calculate index\nresult &lt;- carli_index(prices_current, prices_base)\ncat(\"Carli Index:\", round(result, 4), \"\\n\")\n\nCarli Index: 1.1173 \n\ncat(\"Percentage change:\", round((result - 1) * 100, 2), \"%\\n\")\n\nPercentage change: 11.73 %\n\n# Compare all three indices\nindices &lt;- data.frame(\n  Index = c(\"Jevons\", \"Dutot\", \"Carli\"),\n  Value = c(\n    jevons_index(prices_current, prices_base),\n    dutot_index(prices_current, prices_base),\n    carli_index(prices_current, prices_base)\n  )\n)\n\nindices$Change_Percent &lt;- (indices$Value - 1) * 100\n\nprint(indices)\n\n   Index    Value Change_Percent\n1 Jevons 1.116459       11.64587\n2  Dutot 1.110000       11.00000\n3  Carli 1.117333       11.73333\n\n# Visualization\nggplot(indices, aes(x = Index, y = Change_Percent, fill = Index)) +\n  geom_col(alpha = 0.8) +\n  geom_text(aes(label = paste0(round(Change_Percent, 2), \"%\")), \n            vjust = -0.5, fontface = \"bold\") +\n  scale_fill_manual(values = c(\"#2563eb\", \"#3b82f6\", \"#60a5fa\")) +\n  labs(\n    title = \"Comparison of Elementary Indices\",\n    subtitle = \"Price change from base to current period\",\n    y = \"Percentage Change (%)\",\n    x = \"Index Type\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.position = \"none\",\n    panel.grid.minor = element_blank()\n  )\n\n\n\n\n\n\n\n\n\n\nPython Implementation\n\ndef carli_index(prices_current, prices_base):\n    \"\"\"Calculate Carli price index\"\"\"\n    price_relatives = prices_current / prices_base\n    carli = np.mean(price_relatives)\n    return carli\n\n# Calculate index\nresult = carli_index(prices_current, prices_base)\nprint(f\"Carli Index: {result:.4f}\")\n\nCarli Index: 1.1173\n\nprint(f\"Percentage change: {(result - 1) * 100:.2f}%\")\n\nPercentage change: 11.73%\n\n# Compare all indices\nindices_data = {\n    'Index': ['Jevons', 'Dutot', 'Carli'],\n    'Value': [\n        jevons_index(prices_current, prices_base),\n        dutot_index(prices_current, prices_base),\n        carli_index(prices_current, prices_base)\n    ]\n}\n\nindices_df = pd.DataFrame(indices_data)\nindices_df['Change_Percent'] = (indices_df['Value'] - 1) * 100\n\nprint(\"\\nComparison of Elementary Indices:\")\n\n\nComparison of Elementary Indices:\n\nprint(indices_df)\n\n    Index     Value  Change_Percent\n0  Jevons  1.116459       11.645873\n1   Dutot  1.110000       11.000000\n2   Carli  1.117333       11.733333\n\n# Visualization\nplt.figure(figsize=(10, 6))\ncolors = ['#2563eb', '#3b82f6', '#60a5fa']\nbars = plt.bar(indices_df['Index'], indices_df['Change_Percent'], \n               color=colors, alpha=0.8)\n\nfor i, bar in enumerate(bars):\n    height = bar.get_height()\n    plt.text(bar.get_x() + bar.get_width()/2., height,\n             f'{height:.2f}%', ha='center', va='bottom', \n             fontweight='bold')\n\nplt.title('Comparison of Elementary Indices', fontsize=14, fontweight='bold')\nplt.ylabel('Percentage Change (%)')\nplt.xlabel('Index Type')\nplt.grid(axis='y', alpha=0.3)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "week1.html#guided-exercise",
    "href": "week1.html#guided-exercise",
    "title": "Week 1: Elementary Indices",
    "section": "5. Guided Exercise",
    "text": "5. Guided Exercise\n\n Exercise 1: Calculate Your Own Indices\nUsing the following price data for 6 products over two months:\nJanuary (Base): 5.00, 12.50, 8.00, 15.00, 20.00, 10.00\nFebruary (Current): 5.50, 13.00, 8.50, 16.00, 22.00, 10.50\nTasks: 1. Calculate the Jevons, Dutot, and Carli indices 2. Which index shows the highest price change? 3. Create a visualization comparing the three indices 4. Explain why the indices might differ\nHints: - Use the functions we’ve defined above - Think about the mathematical properties of each index - Consider the impact of different price changes across items\n\n\n Exercise 2: Time Series Analysis\nCreate a time series of prices for 3 items over 6 months and:\n\nCalculate monthly Jevons indices\nCreate a chain index (each month compared to the previous)\nPlot the index over time\nCalculate the cumulative price change\n\nExtension: Compare chain vs. fixed-base indices"
  },
  {
    "objectID": "week1.html#key-takeaways",
    "href": "week1.html#key-takeaways",
    "title": "Week 1: Elementary Indices",
    "section": "6. Key Takeaways",
    "text": "6. Key Takeaways\n\n What You’ve Learned:\n\nJevons Index: Geometric mean, satisfies time reversal test, preferred for many applications\nDutot Index: Ratio of means, simple but unit-dependent\nCarli Index: Arithmetic mean, has upward bias, use with caution\nAll three indices use only prices (no quantities)\nChoice depends on data characteristics and desired properties"
  },
  {
    "objectID": "week1.html#next-steps",
    "href": "week1.html#next-steps",
    "title": "Week 1: Elementary Indices",
    "section": "Next Steps",
    "text": "Next Steps\n\nReady for Week 2?\nNow that you understand elementary indices, you’re ready to learn about weighted bilateral indices that incorporate quantity information.\nWeek 2 Topics: - Fisher Price Index - Törnqvist Price Index - Axiomatic properties - Superlative indices\n Continue to Week 2"
  },
  {
    "objectID": "week1.html#references",
    "href": "week1.html#references",
    "title": "Week 1: Elementary Indices",
    "section": "References",
    "text": "References\n\n\nILO, IMF, OECD, Eurostat, UN, World Bank (2020). Consumer Price Index Manual: Concepts and Methods\nDiewert, W.E. (1995). “Axiomatic and Economic Approaches to Elementary Price Indexes”\nILO (2009). Practical Guide to Producing Consumer Price Indices"
  },
  {
    "objectID": "week4.html",
    "href": "week4.html",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "",
    "text": "Master CCDI, CPD methods, and rolling/linking strategies"
  },
  {
    "objectID": "week4.html#overview",
    "href": "week4.html#overview",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "Overview",
    "text": "Overview\n\nThis final week covers advanced multilateral methods and practical implementation strategies for maintaining long-run price indices.\nLearning Objectives: - Understand CCDI (Coordinated Consumer Price Index) framework - Implement CPD (Country-Product-Dummy) regression method - Master rolling window and linking strategies - Compare different extension methods - Apply best practices for real-world implementation\nTime Required: ~4 hours"
  },
  {
    "objectID": "week4.html#introduction-to-advanced-methods",
    "href": "week4.html#introduction-to-advanced-methods",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "1. Introduction to Advanced Methods",
    "text": "1. Introduction to Advanced Methods\n\nBeyond Basic GEKS\nWhile GEKS ensures transitivity, real-world applications need: - Long time series: How to extend indices beyond the window - New products: How to handle product replacement - Revisions: How to minimize or eliminate revisions - Alternative approaches: Methods like CPD for specific use cases\n\nKey Concept: Advanced methods address the practical challenges of maintaining price indices over extended periods while preserving desirable properties."
  },
  {
    "objectID": "week4.html#ccdi-coordinated-consumer-price-index",
    "href": "week4.html#ccdi-coordinated-consumer-price-index",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "2. CCDI (Coordinated Consumer Price Index)",
    "text": "2. CCDI (Coordinated Consumer Price Index)\n\n\nWhat is CCDI?\nCCDI is a framework for international price comparisons that: - Coordinates across countries - Uses temporal linking - Applies multilateral methods - Ensures consistency across space and time\n\n\nTemporal Linking Approach\nThe key innovation is linking successive GEKS windows:\n\\[\nI_{\\text{CCDI}}(0,t) = I_{\\text{GEKS}}(0,w_1) \\times I_{\\text{GEKS}}(w_1,w_2) \\times \\ldots \\times I_{\\text{GEKS}}(w_{k-1},t)\n\\]\nWhere \\(w_1, w_2, \\ldots, w_{k-1}\\) are link periods between windows.\n\n\nR Implementation\n\nlibrary(tidyverse)\n\n# Generate extended time series\nset.seed(456)\nn_periods &lt;- 24  # 2 years of monthly data\nn_items &lt;- 5\n\nprice_data &lt;- matrix(NA, n_items, n_periods)\nquantity_data &lt;- matrix(NA, n_items, n_periods)\n\n# Initial values\nprice_data[, 1] &lt;- c(10, 20, 15, 25, 30)\nquantity_data[, 1] &lt;- c(100, 50, 80, 40, 30)\n\n# Simulate realistic price movements\nfor (t in 2:n_periods) {\n  # Add seasonal component and trend\n  trend &lt;- 1.002  # 0.2% monthly trend\n  seasonal &lt;- 1 + 0.01 * sin(2 * pi * t / 12)\n  \n  price_data[, t] &lt;- price_data[, t-1] * trend * seasonal * \n                     runif(n_items, 0.99, 1.03)\n  quantity_data[, t] &lt;- quantity_data[, t-1] * \n                        runif(n_items, 0.98, 1.02)\n}\n\n# Fisher bilateral function\nfisher_bilateral &lt;- function(p_s, p_t, q_s, q_t) {\n  laspeyres &lt;- sum(p_t * q_s) / sum(p_s * q_s)\n  paasche &lt;- sum(p_t * q_t) / sum(p_s * q_t)\n  return(sqrt(laspeyres * paasche))\n}\n\n# GEKS function for a window\ngeks_window &lt;- function(price_window, quantity_window) {\n  n_window &lt;- ncol(price_window)\n  indices &lt;- numeric(n_window)\n  indices[1] &lt;- 1\n  \n  for (t in 2:n_window) {\n    # Calculate GEKS for period t relative to period 1\n    bilateral_matrix &lt;- matrix(1, n_window, n_window)\n    \n    for (s in 1:n_window) {\n      for (j in 1:n_window) {\n        if (s != j) {\n          bilateral_matrix[s, j] &lt;- fisher_bilateral(\n            price_window[, s], price_window[, j],\n            quantity_window[, s], quantity_window[, j]\n          )\n        }\n      }\n    }\n    \n    product &lt;- 1\n    for (j in 1:n_window) {\n      product &lt;- product * (bilateral_matrix[1, j] / bilateral_matrix[t, j])\n    }\n    \n    indices[t] &lt;- product^(1/n_window)\n  }\n  \n  return(indices)\n}\n\n# CCDI with rolling windows\nccdi_index &lt;- function(price_data, quantity_data, window_length = 13) {\n  n_periods &lt;- ncol(price_data)\n  indices &lt;- numeric(n_periods)\n  indices[1] &lt;- 1\n  \n  # First window\n  window_end &lt;- min(window_length, n_periods)\n  window_prices &lt;- price_data[, 1:window_end]\n  window_quantities &lt;- quantity_data[, 1:window_end]\n  window_indices &lt;- geks_window(window_prices, window_quantities)\n  indices[1:window_end] &lt;- window_indices\n  \n  # Roll forward\n  if (n_periods &gt; window_length) {\n    for (t in (window_length + 1):n_periods) {\n      # New window\n      window_start &lt;- t - window_length + 1\n      window_end &lt;- t\n      \n      window_prices &lt;- price_data[, window_start:window_end]\n      window_quantities &lt;- quantity_data[, window_start:window_end]\n      window_indices &lt;- geks_window(window_prices, window_quantities)\n      \n      # Link at overlap period\n      link_period &lt;- window_length - 1\n      link_value &lt;- indices[t - 1]\n      \n      # Movement from link period to current\n      movement &lt;- window_indices[window_length] / window_indices[link_period]\n      indices[t] &lt;- link_value * movement\n    }\n  }\n  \n  return(indices)\n}\n\n# Calculate CCDI with different window lengths\nccdi_13 &lt;- ccdi_index(price_data, quantity_data, 13)\nccdi_25 &lt;- ccdi_index(price_data, quantity_data, min(25, n_periods))\n\n# Calculate chain Fisher for comparison\nchain_fisher &lt;- numeric(n_periods)\nchain_fisher[1] &lt;- 1\nfor (t in 2:n_periods) {\n  fisher &lt;- fisher_bilateral(\n    price_data[, t-1], price_data[, t],\n    quantity_data[, t-1], quantity_data[, t]\n  )\n  chain_fisher[t] &lt;- chain_fisher[t-1] * fisher\n}\n\n# Create comparison\ncomparison &lt;- data.frame(\n  Month = 1:n_periods,\n  CCDI_13 = ccdi_13,\n  CCDI_25 = ccdi_25,\n  Chain_Fisher = chain_fisher\n)\n\n# Visualization\ncomparison_long &lt;- comparison %&gt;%\n  pivot_longer(cols = -Month, names_to = \"Method\", values_to = \"Index\")\n\nggplot(comparison_long, aes(x = Month, y = Index, \n                            color = Method, group = Method)) +\n  geom_line(linewidth = 1.2) +\n  geom_point(size = 2) +\n  scale_color_manual(values = c(\n    \"CCDI_13\" = \"#2563eb\",\n    \"CCDI_25\" = \"#10b981\",\n    \"Chain_Fisher\" = \"#f59e0b\"\n  )) +\n  labs(\n    title = \"CCDI Index with Different Window Lengths\",\n    subtitle = \"24 months of simulated price data\",\n    y = \"Price Index (Month 1 = 1.00)\",\n    x = \"Month\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.position = \"bottom\",\n    legend.title = element_blank()\n  )\n\n\n\n\n\n\n\n# Print summary statistics\ncat(\"\\nFinal Index Values (Month 24):\\n\")\n\n\nFinal Index Values (Month 24):\n\ncat(\"CCDI-13:\", round(ccdi_13[n_periods], 4), \"\\n\")\n\nCCDI-13: 1.2944 \n\ncat(\"CCDI-25:\", round(ccdi_25[n_periods], 4), \"\\n\")\n\nCCDI-25: 1.2942 \n\ncat(\"Chain Fisher:\", round(chain_fisher[n_periods], 4), \"\\n\")\n\nChain Fisher: 1.2951 \n\n\n\n\nPython Implementation\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Generate extended time series\nnp.random.seed(456)\nn_periods = 24\nn_items = 5\n\nprice_data = np.zeros((n_items, n_periods))\nquantity_data = np.zeros((n_items, n_periods))\n\n# Initial values\nprice_data[:, 0] = [10, 20, 15, 25, 30]\nquantity_data[:, 0] = [100, 50, 80, 40, 30]\n\n# Simulate with trend and seasonality\nfor t in range(1, n_periods):\n    trend = 1.002\n    seasonal = 1 + 0.01 * np.sin(2 * np.pi * t / 12)\n    \n    price_data[:, t] = price_data[:, t-1] * trend * seasonal * \\\n                       np.random.uniform(0.99, 1.03, n_items)\n    quantity_data[:, t] = quantity_data[:, t-1] * \\\n                          np.random.uniform(0.98, 1.02, n_items)\n\ndef fisher_bilateral(p_s, p_t, q_s, q_t):\n    \"\"\"Calculate bilateral Fisher index\"\"\"\n    laspeyres = np.sum(p_t * q_s) / np.sum(p_s * q_s)\n    paasche = np.sum(p_t * q_t) / np.sum(p_s * q_t)\n    return np.sqrt(laspeyres * paasche)\n\ndef geks_window(price_window, quantity_window):\n    \"\"\"Calculate GEKS indices within a window\"\"\"\n    n_window = price_window.shape[1]\n    indices = np.zeros(n_window)\n    indices[0] = 1.0\n    \n    for t in range(1, n_window):\n        # Calculate bilateral matrix\n        bilateral_matrix = np.ones((n_window, n_window))\n        \n        for s in range(n_window):\n            for j in range(n_window):\n                if s != j:\n                    bilateral_matrix[s, j] = fisher_bilateral(\n                        price_window[:, s], price_window[:, j],\n                        quantity_window[:, s], quantity_window[:, j]\n                    )\n        \n        # Calculate GEKS\n        product = 1.0\n        for j in range(n_window):\n            product *= bilateral_matrix[0, j] / bilateral_matrix[t, j]\n        \n        indices[t] = product ** (1/n_window)\n    \n    return indices\n\ndef ccdi_index(price_data, quantity_data, window_length=13):\n    \"\"\"Calculate CCDI index with rolling windows\"\"\"\n    n_periods = price_data.shape[1]\n    indices = np.zeros(n_periods)\n    indices[0] = 1.0\n    \n    # First window\n    window_end = min(window_length, n_periods)\n    window_prices = price_data[:, 0:window_end]\n    window_quantities = quantity_data[:, 0:window_end]\n    window_indices = geks_window(window_prices, window_quantities)\n    indices[0:window_end] = window_indices\n    \n    # Roll forward\n    if n_periods &gt; window_length:\n        for t in range(window_length, n_periods):\n            # New window\n            window_start = t - window_length + 1\n            window_end = t + 1\n            \n            window_prices = price_data[:, window_start:window_end]\n            window_quantities = quantity_data[:, window_start:window_end]\n            window_indices = geks_window(window_prices, window_quantities)\n            \n            # Link at overlap\n            link_period = window_length - 2\n            link_value = indices[t - 1]\n            \n            # Movement\n            movement = window_indices[-1] / window_indices[link_period]\n            indices[t] = link_value * movement\n    \n    return indices\n\n# Calculate indices\nccdi_13 = ccdi_index(price_data, quantity_data, 13)\nccdi_25 = ccdi_index(price_data, quantity_data, min(25, n_periods))\n\n# Chain Fisher\nchain_fisher = np.zeros(n_periods)\nchain_fisher[0] = 1.0\nfor t in range(1, n_periods):\n    fisher = fisher_bilateral(\n        price_data[:, t-1], price_data[:, t],\n        quantity_data[:, t-1], quantity_data[:, t]\n    )\n    chain_fisher[t] = chain_fisher[t-1] * fisher\n\n# Visualization\nplt.figure(figsize=(12, 7))\nmonths = np.arange(1, n_periods + 1)\n\nplt.plot(months, ccdi_13, 'o-', color='#2563eb', \n         linewidth=2, markersize=6, label='CCDI-13')\nplt.plot(months, ccdi_25, 's-', color='#10b981', \n         linewidth=2, markersize=6, label='CCDI-25')\nplt.plot(months, chain_fisher, '^-', color='#f59e0b', \n         linewidth=2, markersize=6, label='Chain Fisher')\n\nplt.xlabel('Month', fontsize=12)\nplt.ylabel('Price Index (Month 1 = 1.00)', fontsize=12)\nplt.title('CCDI Index with Different Window Lengths', \n          fontsize=14, fontweight='bold')\nplt.legend(fontsize=10)\nplt.grid(alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nprint(\"\\nFinal Index Values (Month 24):\")\n\n\nFinal Index Values (Month 24):\n\nprint(f\"CCDI-13: {ccdi_13[-1]:.4f}\")\n\nCCDI-13: 1.2452\n\nprint(f\"CCDI-25: {ccdi_25[-1]:.4f}\")\n\nCCDI-25: 1.2451\n\nprint(f\"Chain Fisher: {chain_fisher[-1]:.4f}\")\n\nChain Fisher: 1.2454"
  },
  {
    "objectID": "week4.html#cpd-country-product-dummy-method",
    "href": "week4.html#cpd-country-product-dummy-method",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "3. CPD (Country-Product-Dummy) Method",
    "text": "3. CPD (Country-Product-Dummy) Method\n\n\nRegression-Based Approach\nCPD uses regression to estimate price levels:\n\\[\n\\ln p_{it} = \\alpha_i + \\beta_t + \\varepsilon_{it}\n\\]\nWhere: - \\(p_{it}\\) = price of product i in period t - \\(\\alpha_i\\) = product fixed effect - \\(\\beta_t\\) = time fixed effect (the price index) - \\(\\varepsilon_{it}\\) = error term\n\n\nProperties\n\nAdditivity: Works well with many products\nRobustness: Less sensitive to outliers\nFlexibility: Can include other covariates\nInterpretation: Time effects are log price indices\n\n\n\nR Implementation\n\n# Prepare data in long format\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\n\n# --- Données longues (6 périodes) ---\nstopifnot(exists(\"n_items\"), exists(\"price_data\"), exists(\"quantity_data\"))\nTt &lt;- 6\ncpd_data &lt;- tidyr::expand_grid(\n  period = 1:Tt,\n  item   = 1:n_items\n) |&gt;\n  mutate(\n    price     = price_data[cbind(item, period)],\n    quantity  = quantity_data[cbind(item, period)],\n    log_price = log(price),\n    period_factor = factor(period, levels = 1:Tt),\n    item_factor   = factor(item,   levels = 1:n_items)\n  )\n\n# --- Régression CPD : intercept + dummies (période 1 = base) ---\ncpd_model &lt;- lm(log_price ~ item_factor + period_factor, data = cpd_data)\n\n# Effets de période (coef relatifs à la période 1 = 0)\nlev  &lt;- levels(cpd_data$period_factor)\nb    &lt;- coef(cpd_model)\n# noms attendus \"period_factor2\"... selon R\nnm   &lt;- paste0(\"period_factor\", lev[-1])\nbeta &lt;- c(`1` = 0, setNames(b[nm], lev[-1]))\n# Sécurise longueurs/NA\nbeta[is.na(beta)] &lt;- 0\nbeta &lt;- beta[as.character(1:Tt)]\ncpd_indices &lt;- exp(beta - beta[1])  # normalisé: période 1 = 1\n\n# --- Bilatéral Fisher et GEKS sur 6 périodes ---\nfisher_bilateral &lt;- function(p_s, p_j, q_s, q_j){\n  L &lt;- sum(p_j * q_s) / sum(p_s * q_s)\n  P &lt;- sum(p_j * q_j) / sum(p_s * q_j)\n  sqrt(L * P)\n}\n\n# matrice bilatérale une fois pour toutes\nB &lt;- matrix(1, Tt, Tt)\nfor(s in 1:Tt){\n  for(j in 1:Tt){\n    if(s != j){\n      B[s, j] &lt;- fisher_bilateral(\n        price_data[, s], price_data[, j],\n        quantity_data[, s], quantity_data[, j]\n      )\n    }\n  }\n}\n\n# GEKS(t) = exp(mean_k log(B[t,k]) - mean_k log(B[1,k]))\ngeks_6 &lt;- sapply(1:Tt, function(t){\n  exp(mean(log(B[t, ])) - mean(log(B[1, ])))\n})\n\n# --- Comparaison ---\ncomparison_methods &lt;- data.frame(\n  Period = 1:Tt,\n  CPD    = as.numeric(cpd_indices),\n  GEKS   = as.numeric(geks_6)\n)\nprint(comparison_methods)\n\n  Period      CPD      GEKS\n1      1 1.000000 1.0000000\n2      2 1.022106 0.9782326\n3      3 1.046899 0.9546768\n4      4 1.073601 0.9305930\n5      5 1.098813 0.9087604\n6      6 1.098704 0.9090691\n\n# --- Viz ---\ncomparison_methods_long &lt;- comparison_methods |&gt;\n  pivot_longer(cols = -Period, names_to = \"Method\", values_to = \"Index\")\n\nggplot(comparison_methods_long, aes(Period, Index, color = Method, group = Method)) +\n  geom_line(linewidth = 1.2) + geom_point(size = 3) +\n  scale_color_manual(values = c(\"CPD\" = \"#8b5cf6\", \"GEKS\" = \"#2563eb\")) +\n  labs(title = \"CPD vs GEKS\", subtitle = \"Effets période (CPD) vs GEKS multilatéral\",\n       y = \"Indice (Période 1 = 1.00)\", x = \"Période\") +\n  theme_minimal(base_size = 12) +\n  theme(legend.position = \"bottom\", legend.title = element_blank())\n\n\n\n\n\n\n\n# Model diagnostics\ncat(\"\\nCPD Model R-squared:\", round(summary(cpd_model)$r.squared, 4), \"\\n\")\n\n\nCPD Model R-squared: 0.9992 \n\n\n\n\nPython Implementation"
  },
  {
    "objectID": "week4.html#rolling-and-linking-strategies",
    "href": "week4.html#rolling-and-linking-strategies",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "4. Rolling and Linking Strategies",
    "text": "4. Rolling and Linking Strategies\n\n\nExtension Methods\nThree main approaches for extending multilateral indices:\n\nMovement Splice: Use movement from new window\nWindow Splice: Use level from overlap period\nHalf Splice: Average of movement and window splice\n\n\n\nComparison of Methods\n\n# Implement different splicing methods\nwindow_length &lt;- 13\n\n# Movement splice (already implemented as CCDI)\nmovement_splice &lt;- ccdi_13\n\n# Window splice: use direct value from new window\nwindow_splice &lt;- numeric(n_periods)\nwindow_splice[1] &lt;- 1\n\nfor (t in 2:n_periods) {\n  if (t &lt;= window_length) {\n    window_start &lt;- 1\n  } else {\n    window_start &lt;- t - window_length + 1\n  }\n  \n  window_prices &lt;- price_data[, window_start:t]\n  window_quantities &lt;- quantity_data[, window_start:t]\n  window_indices &lt;- geks_window(window_prices, window_quantities)\n  \n  window_splice[t] &lt;- window_indices[length(window_indices)]\n}\n\n# Half splice: average of both\nhalf_splice &lt;- (movement_splice + window_splice) / 2\n\n# Compare methods\nsplicing_comparison &lt;- data.frame(\n  Month = 1:n_periods,\n  Movement = movement_splice,\n  Window = window_splice,\n  Half = half_splice\n)\n\nprint(tail(splicing_comparison, 12))\n\n   Month Movement   Window     Half\n13    13 1.164933 1.164933 1.164933\n14    14 1.177863 1.152264 1.165063\n15    15 1.210012 1.155266 1.182639\n16    16 1.227225 1.142134 1.184680\n17    17 1.246669 1.133057 1.189863\n18    18 1.262028 1.147312 1.204670\n19    19 1.269041 1.143457 1.206249\n20    20 1.271754 1.149940 1.210847\n21    21 1.276029 1.151223 1.213626\n22    22 1.281725 1.147611 1.214668\n23    23 1.286381 1.133838 1.210110\n24    24 1.294380 1.133812 1.214096\n\n# Visualization\nsplicing_long &lt;- splicing_comparison %&gt;%\n  pivot_longer(cols = -Month, names_to = \"Method\", values_to = \"Index\")\n\nggplot(splicing_long, aes(x = Month, y = Index, \n                          color = Method, group = Method)) +\n  geom_line(linewidth = 1.2) +\n  scale_color_manual(values = c(\n    \"Movement\" = \"#2563eb\",\n    \"Window\" = \"#10b981\",\n    \"Half\" = \"#8b5cf6\"\n  )) +\n  labs(\n    title = \"Comparison of Splicing Methods\",\n    subtitle = \"Different approaches to extending multilateral indices\",\n    y = \"Price Index (Month 1 = 1.00)\",\n    x = \"Month\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(face = \"bold\", size = 14),\n    legend.position = \"bottom\",\n    legend.title = element_blank()\n  )"
  },
  {
    "objectID": "week4.html#guided-exercise",
    "href": "week4.html#guided-exercise",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "5. Guided Exercise",
    "text": "5. Guided Exercise\n\n Exercise 1: Implement CCDI\nCreate a 36-month time series and: 1. Implement CCDI with 13-month window 2. Calculate revisions when new data arrives 3. Compare with chain Fisher index 4. Analyze the revision pattern\nChallenge: Implement a revision-free extension method\n\n\n Exercise 2: CPD Analysis\nUsing the provided data: 1. Run CPD regression with product and time dummies 2. Add quality adjustment variables 3. Compare CPD with GEKS-Törnqvist 4. Interpret the regression coefficients\nExtension: Test for seasonality in the residuals"
  },
  {
    "objectID": "week4.html#key-takeaways",
    "href": "week4.html#key-takeaways",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "6. Key Takeaways",
    "text": "6. Key Takeaways\n\n What You’ve Learned:\n\nCCDI: Framework for coordinating multilateral indices over time\nCPD: Regression-based alternative with different properties\nRolling windows: Practical approach for extending time series\nLinking strategies: Movement, window, and half splice methods\nTrade-offs: Balance between revisions, data use, and properties"
  },
  {
    "objectID": "week4.html#congratulations",
    "href": "week4.html#congratulations",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "Congratulations! 🎉",
    "text": "Congratulations! 🎉\n\n\nYou’ve Completed the Learning Path!\nOver these 4 weeks, you’ve mastered:\n✅ Elementary indices (Jevons, Dutot, Carli)\n✅ Superlative bilateral indices (Fisher, Törnqvist)\n✅ Multilateral methods (GEKS, GEKS-T)\n✅ Advanced techniques (CCDI, CPD, linking)\n\n\nNext Steps\n\nApply these methods to real datasets\nExplore specialized topics (scanner data, quality adjustment)\nRead the academic literature\nContribute to open-source price index software\n\n\n\nResources\n\nR Packages: PriceIndices, IndexNumR\nPython Libraries: pandas, statsmodels\nDocumentation: ILO CPI Manual, PPI Manual\nCommunity: Join price statistics forums and working groups\n\n Return to Dashboard"
  },
  {
    "objectID": "week4.html#final-exercise",
    "href": "week4.html#final-exercise",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "Final Exercise",
    "text": "Final Exercise\n\n Capstone Project\nBuild a Complete Price Index System\nUsing 24+ months of simulated or real price data:\n\nData Preparation\n\nClean and validate price and quantity data\nHandle missing values and outliers\n\nElementary Aggregation\n\nCalculate Jevons indices at lowest level\nCompare with Dutot and Carli\n\nHigher-Level Aggregation\n\nImplement Fisher and Törnqvist indices\nCalculate with appropriate weights\n\nMultilateral Implementation\n\nApply GEKS or GEKS-T method\nImplement rolling windows\n\nExtension Strategy\n\nChoose and implement linking method\nAnalyze revisions\n\nVisualization\n\nCreate dashboard with key indicators\nShow index evolution over time\nCompare different methods\n\nDocumentation\n\nWrite methodology notes\nDocument data sources\nExplain design choices\n\n\nDeliverables: - Working code in R and/or Python - Comprehensive visualizations - Written methodology report - Presentation of results"
  },
  {
    "objectID": "week4.html#references-further-reading",
    "href": "week4.html#references-further-reading",
    "title": "Week 4: CCDI, CPD & Linking",
    "section": "References & Further Reading",
    "text": "References & Further Reading\n\n\nKey Publications\n\nILO, IMF, OECD, Eurostat, UN, World Bank (2020). Consumer Price Index Manual: Concepts and Methods\nIMF (2009). Export and Import Price Index Manual: Theory and Practice\nDiewert, W.E., & Fox, K.J. (2020). Measuring Real Consumption and CPI Bias\n\n\n\nAcademic Papers\n\nIvancic, L., Diewert, W.E., & Fox, K.J. (2011). “Scanner Data, Time Aggregation and the Construction of Price Indexes”\nKrsinich, F. (2016). “The FEWS Index: Fixed Effects with a Window Splice”\nde Haan, J., & van der Grient, H.A. (2011). “Eliminating Chain Drift in Price Indexes”\n\n\n\nOnline Resources\n\nUNECE CPI Training Materials\nOttawa Group Papers\nVoorburg Group Documentation\nStatistical Agency Methodologies"
  }
]