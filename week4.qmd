---
title: "Week 4: CCDI, CPD & Linking"
format: html
---

```{r}
#| label: setup-reticulate
#| include: false
#| echo: false
library(reticulate)
use_virtualenv("r-reticulate", required = TRUE)  # ou use_condaenv("r-reticulate", required=TRUE)
py_config()  # pour vÃ©rifier le Python actif
```


::: {.week-header}
# Week 4: Advanced Techniques
Master CCDI, CPD methods, and rolling/linking strategies
:::

## Overview

::: {.content-card}

This final week covers advanced multilateral methods and practical implementation strategies for maintaining long-run price indices.

**Learning Objectives:**
- Understand CCDI (Coordinated Consumer Price Index) framework
- Implement CPD (Country-Product-Dummy) regression method
- Master rolling window and linking strategies
- Compare different extension methods
- Apply best practices for real-world implementation

**Time Required:** ~4 hours
:::

## 1. Introduction to Advanced Methods

::: {.content-card}

### Beyond Basic GEKS

While GEKS ensures transitivity, real-world applications need:
- **Long time series**: How to extend indices beyond the window
- **New products**: How to handle product replacement
- **Revisions**: How to minimize or eliminate revisions
- **Alternative approaches**: Methods like CPD for specific use cases

::: {.info-box}
**Key Concept:** Advanced methods address the practical challenges of maintaining price indices over extended periods while preserving desirable properties.
:::

:::

## 2. CCDI (Coordinated Consumer Price Index)

::: {.content-card}

### What is CCDI?

CCDI is a framework for international price comparisons that:
- Coordinates across countries
- Uses temporal linking
- Applies multilateral methods
- Ensures consistency across space and time

### Temporal Linking Approach

The key innovation is linking successive GEKS windows:

$$
I_{\text{CCDI}}(0,t) = I_{\text{GEKS}}(0,w_1) \times I_{\text{GEKS}}(w_1,w_2) \times \ldots \times I_{\text{GEKS}}(w_{k-1},t)
$$

Where $w_1, w_2, \ldots, w_{k-1}$ are link periods between windows.

### R Implementation

```{r}
#| label: ccdi-r
#| echo: true

library(tidyverse)

# Generate extended time series
set.seed(456)
n_periods <- 24  # 2 years of monthly data
n_items <- 5

price_data <- matrix(NA, n_items, n_periods)
quantity_data <- matrix(NA, n_items, n_periods)

# Initial values
price_data[, 1] <- c(10, 20, 15, 25, 30)
quantity_data[, 1] <- c(100, 50, 80, 40, 30)

# Simulate realistic price movements
for (t in 2:n_periods) {
  # Add seasonal component and trend
  trend <- 1.002  # 0.2% monthly trend
  seasonal <- 1 + 0.01 * sin(2 * pi * t / 12)
  
  price_data[, t] <- price_data[, t-1] * trend * seasonal * 
                     runif(n_items, 0.99, 1.03)
  quantity_data[, t] <- quantity_data[, t-1] * 
                        runif(n_items, 0.98, 1.02)
}

# Fisher bilateral function
fisher_bilateral <- function(p_s, p_t, q_s, q_t) {
  laspeyres <- sum(p_t * q_s) / sum(p_s * q_s)
  paasche <- sum(p_t * q_t) / sum(p_s * q_t)
  return(sqrt(laspeyres * paasche))
}

# GEKS function for a window
geks_window <- function(price_window, quantity_window) {
  n_window <- ncol(price_window)
  indices <- numeric(n_window)
  indices[1] <- 1
  
  for (t in 2:n_window) {
    # Calculate GEKS for period t relative to period 1
    bilateral_matrix <- matrix(1, n_window, n_window)
    
    for (s in 1:n_window) {
      for (j in 1:n_window) {
        if (s != j) {
          bilateral_matrix[s, j] <- fisher_bilateral(
            price_window[, s], price_window[, j],
            quantity_window[, s], quantity_window[, j]
          )
        }
      }
    }
    
    product <- 1
    for (j in 1:n_window) {
      product <- product * (bilateral_matrix[1, j] / bilateral_matrix[t, j])
    }
    
    indices[t] <- product^(1/n_window)
  }
  
  return(indices)
}

# CCDI with rolling windows
ccdi_index <- function(price_data, quantity_data, window_length = 13) {
  n_periods <- ncol(price_data)
  indices <- numeric(n_periods)
  indices[1] <- 1
  
  # First window
  window_end <- min(window_length, n_periods)
  window_prices <- price_data[, 1:window_end]
  window_quantities <- quantity_data[, 1:window_end]
  window_indices <- geks_window(window_prices, window_quantities)
  indices[1:window_end] <- window_indices
  
  # Roll forward
  if (n_periods > window_length) {
    for (t in (window_length + 1):n_periods) {
      # New window
      window_start <- t - window_length + 1
      window_end <- t
      
      window_prices <- price_data[, window_start:window_end]
      window_quantities <- quantity_data[, window_start:window_end]
      window_indices <- geks_window(window_prices, window_quantities)
      
      # Link at overlap period
      link_period <- window_length - 1
      link_value <- indices[t - 1]
      
      # Movement from link period to current
      movement <- window_indices[window_length] / window_indices[link_period]
      indices[t] <- link_value * movement
    }
  }
  
  return(indices)
}

# Calculate CCDI with different window lengths
ccdi_13 <- ccdi_index(price_data, quantity_data, 13)
ccdi_25 <- ccdi_index(price_data, quantity_data, min(25, n_periods))

# Calculate chain Fisher for comparison
chain_fisher <- numeric(n_periods)
chain_fisher[1] <- 1
for (t in 2:n_periods) {
  fisher <- fisher_bilateral(
    price_data[, t-1], price_data[, t],
    quantity_data[, t-1], quantity_data[, t]
  )
  chain_fisher[t] <- chain_fisher[t-1] * fisher
}

# Create comparison
comparison <- data.frame(
  Month = 1:n_periods,
  CCDI_13 = ccdi_13,
  CCDI_25 = ccdi_25,
  Chain_Fisher = chain_fisher
)

# Visualization
comparison_long <- comparison %>%
  pivot_longer(cols = -Month, names_to = "Method", values_to = "Index")

ggplot(comparison_long, aes(x = Month, y = Index, 
                            color = Method, group = Method)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2) +
  scale_color_manual(values = c(
    "CCDI_13" = "#2563eb",
    "CCDI_25" = "#10b981",
    "Chain_Fisher" = "#f59e0b"
  )) +
  labs(
    title = "CCDI Index with Different Window Lengths",
    subtitle = "24 months of simulated price data",
    y = "Price Index (Month 1 = 1.00)",
    x = "Month"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    legend.title = element_blank()
  )

# Print summary statistics
cat("\nFinal Index Values (Month 24):\n")
cat("CCDI-13:", round(ccdi_13[n_periods], 4), "\n")
cat("CCDI-25:", round(ccdi_25[n_periods], 4), "\n")
cat("Chain Fisher:", round(chain_fisher[n_periods], 4), "\n")
```

### Python Implementation

```{python}
#| label: ccdi-python
#| echo: true

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Generate extended time series
np.random.seed(456)
n_periods = 24
n_items = 5

price_data = np.zeros((n_items, n_periods))
quantity_data = np.zeros((n_items, n_periods))

# Initial values
price_data[:, 0] = [10, 20, 15, 25, 30]
quantity_data[:, 0] = [100, 50, 80, 40, 30]

# Simulate with trend and seasonality
for t in range(1, n_periods):
    trend = 1.002
    seasonal = 1 + 0.01 * np.sin(2 * np.pi * t / 12)
    
    price_data[:, t] = price_data[:, t-1] * trend * seasonal * \
                       np.random.uniform(0.99, 1.03, n_items)
    quantity_data[:, t] = quantity_data[:, t-1] * \
                          np.random.uniform(0.98, 1.02, n_items)

def fisher_bilateral(p_s, p_t, q_s, q_t):
    """Calculate bilateral Fisher index"""
    laspeyres = np.sum(p_t * q_s) / np.sum(p_s * q_s)
    paasche = np.sum(p_t * q_t) / np.sum(p_s * q_t)
    return np.sqrt(laspeyres * paasche)

def geks_window(price_window, quantity_window):
    """Calculate GEKS indices within a window"""
    n_window = price_window.shape[1]
    indices = np.zeros(n_window)
    indices[0] = 1.0
    
    for t in range(1, n_window):
        # Calculate bilateral matrix
        bilateral_matrix = np.ones((n_window, n_window))
        
        for s in range(n_window):
            for j in range(n_window):
                if s != j:
                    bilateral_matrix[s, j] = fisher_bilateral(
                        price_window[:, s], price_window[:, j],
                        quantity_window[:, s], quantity_window[:, j]
                    )
        
        # Calculate GEKS
        product = 1.0
        for j in range(n_window):
            product *= bilateral_matrix[0, j] / bilateral_matrix[t, j]
        
        indices[t] = product ** (1/n_window)
    
    return indices

def ccdi_index(price_data, quantity_data, window_length=13):
    """Calculate CCDI index with rolling windows"""
    n_periods = price_data.shape[1]
    indices = np.zeros(n_periods)
    indices[0] = 1.0
    
    # First window
    window_end = min(window_length, n_periods)
    window_prices = price_data[:, 0:window_end]
    window_quantities = quantity_data[:, 0:window_end]
    window_indices = geks_window(window_prices, window_quantities)
    indices[0:window_end] = window_indices
    
    # Roll forward
    if n_periods > window_length:
        for t in range(window_length, n_periods):
            # New window
            window_start = t - window_length + 1
            window_end = t + 1
            
            window_prices = price_data[:, window_start:window_end]
            window_quantities = quantity_data[:, window_start:window_end]
            window_indices = geks_window(window_prices, window_quantities)
            
            # Link at overlap
            link_period = window_length - 2
            link_value = indices[t - 1]
            
            # Movement
            movement = window_indices[-1] / window_indices[link_period]
            indices[t] = link_value * movement
    
    return indices

# Calculate indices
ccdi_13 = ccdi_index(price_data, quantity_data, 13)
ccdi_25 = ccdi_index(price_data, quantity_data, min(25, n_periods))

# Chain Fisher
chain_fisher = np.zeros(n_periods)
chain_fisher[0] = 1.0
for t in range(1, n_periods):
    fisher = fisher_bilateral(
        price_data[:, t-1], price_data[:, t],
        quantity_data[:, t-1], quantity_data[:, t]
    )
    chain_fisher[t] = chain_fisher[t-1] * fisher

# Visualization
plt.figure(figsize=(12, 7))
months = np.arange(1, n_periods + 1)

plt.plot(months, ccdi_13, 'o-', color='#2563eb', 
         linewidth=2, markersize=6, label='CCDI-13')
plt.plot(months, ccdi_25, 's-', color='#10b981', 
         linewidth=2, markersize=6, label='CCDI-25')
plt.plot(months, chain_fisher, '^-', color='#f59e0b', 
         linewidth=2, markersize=6, label='Chain Fisher')

plt.xlabel('Month', fontsize=12)
plt.ylabel('Price Index (Month 1 = 1.00)', fontsize=12)
plt.title('CCDI Index with Different Window Lengths', 
          fontsize=14, fontweight='bold')
plt.legend(fontsize=10)
plt.grid(alpha=0.3)
plt.tight_layout()
plt.show()

print("\nFinal Index Values (Month 24):")
print(f"CCDI-13: {ccdi_13[-1]:.4f}")
print(f"CCDI-25: {ccdi_25[-1]:.4f}")
print(f"Chain Fisher: {chain_fisher[-1]:.4f}")
```

:::

## 3. CPD (Country-Product-Dummy) Method

::: {.content-card}

### Regression-Based Approach

CPD uses regression to estimate price levels:

$$
\ln p_{it} = \alpha_i + \beta_t + \varepsilon_{it}
$$

Where:
- $p_{it}$ = price of product i in period t
- $\alpha_i$ = product fixed effect
- $\beta_t$ = time fixed effect (the price index)
- $\varepsilon_{it}$ = error term

### Properties

- **Additivity**: Works well with many products
- **Robustness**: Less sensitive to outliers
- **Flexibility**: Can include other covariates
- **Interpretation**: Time effects are log price indices

### R Implementation

```{r}
#| label: cpd-r
#| echo: true

# Prepare data in long format
library(dplyr)
library(tidyr)
library(ggplot2)

# --- DonnÃ©es longues (6 pÃ©riodes) ---
stopifnot(exists("n_items"), exists("price_data"), exists("quantity_data"))
Tt <- 6
cpd_data <- tidyr::expand_grid(
  period = 1:Tt,
  item   = 1:n_items
) |>
  mutate(
    price     = price_data[cbind(item, period)],
    quantity  = quantity_data[cbind(item, period)],
    log_price = log(price),
    period_factor = factor(period, levels = 1:Tt),
    item_factor   = factor(item,   levels = 1:n_items)
  )

# --- RÃ©gression CPD : intercept + dummies (pÃ©riode 1 = base) ---
cpd_model <- lm(log_price ~ item_factor + period_factor, data = cpd_data)

# Effets de pÃ©riode (coef relatifs Ã  la pÃ©riode 1 = 0)
lev  <- levels(cpd_data$period_factor)
b    <- coef(cpd_model)
# noms attendus "period_factor2"... selon R
nm   <- paste0("period_factor", lev[-1])
beta <- c(`1` = 0, setNames(b[nm], lev[-1]))
# SÃ©curise longueurs/NA
beta[is.na(beta)] <- 0
beta <- beta[as.character(1:Tt)]
cpd_indices <- exp(beta - beta[1])  # normalisÃ©: pÃ©riode 1 = 1

# --- BilatÃ©ral Fisher et GEKS sur 6 pÃ©riodes ---
fisher_bilateral <- function(p_s, p_j, q_s, q_j){
  L <- sum(p_j * q_s) / sum(p_s * q_s)
  P <- sum(p_j * q_j) / sum(p_s * q_j)
  sqrt(L * P)
}

# matrice bilatÃ©rale une fois pour toutes
B <- matrix(1, Tt, Tt)
for(s in 1:Tt){
  for(j in 1:Tt){
    if(s != j){
      B[s, j] <- fisher_bilateral(
        price_data[, s], price_data[, j],
        quantity_data[, s], quantity_data[, j]
      )
    }
  }
}

# GEKS(t) = exp(mean_k log(B[t,k]) - mean_k log(B[1,k]))
geks_6 <- sapply(1:Tt, function(t){
  exp(mean(log(B[t, ])) - mean(log(B[1, ])))
})

# --- Comparaison ---
comparison_methods <- data.frame(
  Period = 1:Tt,
  CPD    = as.numeric(cpd_indices),
  GEKS   = as.numeric(geks_6)
)
print(comparison_methods)

# --- Viz ---
comparison_methods_long <- comparison_methods |>
  pivot_longer(cols = -Period, names_to = "Method", values_to = "Index")

ggplot(comparison_methods_long, aes(Period, Index, color = Method, group = Method)) +
  geom_line(linewidth = 1.2) + geom_point(size = 3) +
  scale_color_manual(values = c("CPD" = "#8b5cf6", "GEKS" = "#2563eb")) +
  labs(title = "CPD vs GEKS", subtitle = "Effets pÃ©riode (CPD) vs GEKS multilatÃ©ral",
       y = "Indice (PÃ©riode 1 = 1.00)", x = "PÃ©riode") +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom", legend.title = element_blank())

# Model diagnostics
cat("\nCPD Model R-squared:", round(summary(cpd_model)$r.squared, 4), "\n")


```

### Python Implementation


:::

## 4. Rolling and Linking Strategies

::: {.content-card}

### Extension Methods

Three main approaches for extending multilateral indices:

1. **Movement Splice**: Use movement from new window
2. **Window Splice**: Use level from overlap period
3. **Half Splice**: Average of movement and window splice

### Comparison of Methods

```{r}
#| label: linking-r
#| echo: true

# Implement different splicing methods
window_length <- 13

# Movement splice (already implemented as CCDI)
movement_splice <- ccdi_13

# Window splice: use direct value from new window
window_splice <- numeric(n_periods)
window_splice[1] <- 1

for (t in 2:n_periods) {
  if (t <= window_length) {
    window_start <- 1
  } else {
    window_start <- t - window_length + 1
  }
  
  window_prices <- price_data[, window_start:t]
  window_quantities <- quantity_data[, window_start:t]
  window_indices <- geks_window(window_prices, window_quantities)
  
  window_splice[t] <- window_indices[length(window_indices)]
}

# Half splice: average of both
half_splice <- (movement_splice + window_splice) / 2

# Compare methods
splicing_comparison <- data.frame(
  Month = 1:n_periods,
  Movement = movement_splice,
  Window = window_splice,
  Half = half_splice
)

print(tail(splicing_comparison, 12))

# Visualization
splicing_long <- splicing_comparison %>%
  pivot_longer(cols = -Month, names_to = "Method", values_to = "Index")

ggplot(splicing_long, aes(x = Month, y = Index, 
                          color = Method, group = Method)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c(
    "Movement" = "#2563eb",
    "Window" = "#10b981",
    "Half" = "#8b5cf6"
  )) +
  labs(
    title = "Comparison of Splicing Methods",
    subtitle = "Different approaches to extending multilateral indices",
    y = "Price Index (Month 1 = 1.00)",
    x = "Month"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "bottom",
    legend.title = element_blank()
  )
```

:::

## 5. Guided Exercise

::: {.exercise-box}
### <i class="bi bi-pencil-square"></i> Exercise 1: Implement CCDI

Create a 36-month time series and:
1. Implement CCDI with 13-month window
2. Calculate revisions when new data arrives
3. Compare with chain Fisher index
4. Analyze the revision pattern

**Challenge**: Implement a revision-free extension method
:::

::: {.exercise-box}
### <i class="bi bi-pencil-square"></i> Exercise 2: CPD Analysis

Using the provided data:
1. Run CPD regression with product and time dummies
2. Add quality adjustment variables
3. Compare CPD with GEKS-TÃ¶rnqvist
4. Interpret the regression coefficients

**Extension**: Test for seasonality in the residuals
:::

## 6. Key Takeaways

::: {.info-box .success}
**<i class="bi bi-check-circle"></i> What You've Learned:**

- **CCDI**: Framework for coordinating multilateral indices over time
- **CPD**: Regression-based alternative with different properties
- **Rolling windows**: Practical approach for extending time series
- **Linking strategies**: Movement, window, and half splice methods
- **Trade-offs**: Balance between revisions, data use, and properties
:::

## Congratulations! ðŸŽ‰

::: {.content-card}

### You've Completed the Learning Path!

Over these 4 weeks, you've mastered:

âœ… Elementary indices (Jevons, Dutot, Carli)  
âœ… Superlative bilateral indices (Fisher, TÃ¶rnqvist)  
âœ… Multilateral methods (GEKS, GEKS-T)  
âœ… Advanced techniques (CCDI, CPD, linking)

### Next Steps

- Apply these methods to real datasets
- Explore specialized topics (scanner data, quality adjustment)
- Read the academic literature
- Contribute to open-source price index software

### Resources

- **R Packages**: `PriceIndices`, `IndexNumR`
- **Python Libraries**: `pandas`, `statsmodels`
- **Documentation**: ILO CPI Manual, PPI Manual
- **Community**: Join price statistics forums and working groups

[<i class="bi bi-house"></i> Return to Dashboard](index.qmd){.btn .btn-primary}

:::

## Final Exercise

::: {.exercise-box}
### <i class="bi bi-trophy"></i> Capstone Project

**Build a Complete Price Index System**

Using 24+ months of simulated or real price data:

1. **Data Preparation**
   - Clean and validate price and quantity data
   - Handle missing values and outliers

2. **Elementary Aggregation**
   - Calculate Jevons indices at lowest level
   - Compare with Dutot and Carli

3. **Higher-Level Aggregation**
   - Implement Fisher and TÃ¶rnqvist indices
   - Calculate with appropriate weights

4. **Multilateral Implementation**
   - Apply GEKS or GEKS-T method
   - Implement rolling windows

5. **Extension Strategy**
   - Choose and implement linking method
   - Analyze revisions

6. **Visualization**
   - Create dashboard with key indicators
   - Show index evolution over time
   - Compare different methods

7. **Documentation**
   - Write methodology notes
   - Document data sources
   - Explain design choices

**Deliverables:**
- Working code in R and/or Python
- Comprehensive visualizations
- Written methodology report
- Presentation of results
:::

## References & Further Reading

::: {.content-card}

### Key Publications

- ILO, IMF, OECD, Eurostat, UN, World Bank (2020). *Consumer Price Index Manual: Concepts and Methods*
- IMF (2009). *Export and Import Price Index Manual: Theory and Practice*
- Diewert, W.E., & Fox, K.J. (2020). *Measuring Real Consumption and CPI Bias*

### Academic Papers

- Ivancic, L., Diewert, W.E., & Fox, K.J. (2011). "Scanner Data, Time Aggregation and the Construction of Price Indexes"
- Krsinich, F. (2016). "The FEWS Index: Fixed Effects with a Window Splice"
- de Haan, J., & van der Grient, H.A. (2011). "Eliminating Chain Drift in Price Indexes"

### Online Resources

- UNECE CPI Training Materials
- Ottawa Group Papers
- Voorburg Group Documentation
- Statistical Agency Methodologies

:::
